// Code generated by protoc-gen-go.
// source: spec/build.proto
// DO NOT EDIT!

/*
Package spec is a generated protocol buffer package.

It is generated from these files:
	spec/build.proto
	spec/runner.proto

It has these top-level messages:
	Package
	PackageOptions
	Reference
	LocalFinder
	PythonLocalFinder
	Target
	Dependency
	DependencyOptions
	TargetDependency
	GoDependency
	PipDependency
	CommandTarget
	GoBinaryTarget
	PythonLibTarget
	DockerImageTarget
	DockerImageBuildCommand
	FileSource
	File
	Artifact
	RunCommand
	RunProcess
	RunProcessState
	RunProcessLog
*/
package spec

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Package
type Package struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Remote (URI)
	Remote string `protobuf:"bytes,2,opt,name=remote" json:"remote,omitempty"`
	// References
	References map[string]*Reference `protobuf:"bytes,3,rep,name=references" json:"references,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Targets
	Targets map[string]*Target `protobuf:"bytes,4,rep,name=targets" json:"targets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Options
	Options *PackageOptions `protobuf:"bytes,15,opt,name=options" json:"options,omitempty"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

func (m *Package) GetReferences() map[string]*Reference {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *Package) GetTargets() map[string]*Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *Package) GetOptions() *PackageOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Package options
type PackageOptions struct {
	// Default targets (to build)
	DefaultTargets []string `protobuf:"bytes,1,rep,name=defaultTargets" json:"defaultTargets,omitempty"`
}

func (m *PackageOptions) Reset()                    { *m = PackageOptions{} }
func (m *PackageOptions) String() string            { return proto.CompactTextString(m) }
func (*PackageOptions) ProtoMessage()               {}
func (*PackageOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *PackageOptions) GetDefaultTargets() []string {
	if m != nil {
		return m.DefaultTargets
	}
	return nil
}

// Reference
type Reference struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Remote
	Remote string `protobuf:"bytes,2,opt,name=remote" json:"remote,omitempty"`
	// Local finders
	LocalFinders []*LocalFinder `protobuf:"bytes,3,rep,name=localFinders" json:"localFinders,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *Reference) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Reference) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

func (m *Reference) GetLocalFinders() []*LocalFinder {
	if m != nil {
		return m.LocalFinders
	}
	return nil
}

// Local finder
type LocalFinder struct {
	// Finder name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Finders
	//
	// Types that are valid to be assigned to Finder:
	//	*LocalFinder_Python
	Finder isLocalFinder_Finder `protobuf_oneof:"Finder"`
}

func (m *LocalFinder) Reset()                    { *m = LocalFinder{} }
func (m *LocalFinder) String() string            { return proto.CompactTextString(m) }
func (*LocalFinder) ProtoMessage()               {}
func (*LocalFinder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

type isLocalFinder_Finder interface {
	isLocalFinder_Finder()
}

type LocalFinder_Python struct {
	Python *PythonLocalFinder `protobuf:"bytes,2,opt,name=python,oneof"`
}

func (*LocalFinder_Python) isLocalFinder_Finder() {}

func (m *LocalFinder) GetFinder() isLocalFinder_Finder {
	if m != nil {
		return m.Finder
	}
	return nil
}

func (m *LocalFinder) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *LocalFinder) GetPython() *PythonLocalFinder {
	if x, ok := m.GetFinder().(*LocalFinder_Python); ok {
		return x.Python
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*LocalFinder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _LocalFinder_OneofMarshaler, _LocalFinder_OneofUnmarshaler, _LocalFinder_OneofSizer, []interface{}{
		(*LocalFinder_Python)(nil),
	}
}

func _LocalFinder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*LocalFinder)
	// Finder
	switch x := m.Finder.(type) {
	case *LocalFinder_Python:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Python); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("LocalFinder.Finder has unexpected type %T", x)
	}
	return nil
}

func _LocalFinder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*LocalFinder)
	switch tag {
	case 2: // Finder.python
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PythonLocalFinder)
		err := b.DecodeMessage(msg)
		m.Finder = &LocalFinder_Python{msg}
		return true, err
	default:
		return false, nil
	}
}

func _LocalFinder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*LocalFinder)
	// Finder
	switch x := m.Finder.(type) {
	case *LocalFinder_Python:
		s := proto.Size(x.Python)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Python local finder
type PythonLocalFinder struct {
	// Python module name
	Module string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
	// The number of parent dirs
	Parent int32 `protobuf:"varint,2,opt,name=parent" json:"parent,omitempty"`
}

func (m *PythonLocalFinder) Reset()                    { *m = PythonLocalFinder{} }
func (m *PythonLocalFinder) String() string            { return proto.CompactTextString(m) }
func (*PythonLocalFinder) ProtoMessage()               {}
func (*PythonLocalFinder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PythonLocalFinder) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *PythonLocalFinder) GetParent() int32 {
	if m != nil {
		return m.Parent
	}
	return 0
}

// Target
type Target struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Dependencies
	Dependencies []*Dependency `protobuf:"bytes,2,rep,name=dependencies" json:"dependencies,omitempty"`
	// Target
	//
	// Types that are valid to be assigned to Target:
	//	*Target_Command
	//	*Target_GoBinary
	//	*Target_PythonLib
	//	*Target_DockerImage
	Target isTarget_Target `protobuf_oneof:"Target"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

type isTarget_Target interface {
	isTarget_Target()
}

type Target_Command struct {
	Command *CommandTarget `protobuf:"bytes,5,opt,name=command,oneof"`
}
type Target_GoBinary struct {
	GoBinary *GoBinaryTarget `protobuf:"bytes,6,opt,name=goBinary,oneof"`
}
type Target_PythonLib struct {
	PythonLib *PythonLibTarget `protobuf:"bytes,7,opt,name=pythonLib,oneof"`
}
type Target_DockerImage struct {
	DockerImage *DockerImageTarget `protobuf:"bytes,8,opt,name=dockerImage,oneof"`
}

func (*Target_Command) isTarget_Target()     {}
func (*Target_GoBinary) isTarget_Target()    {}
func (*Target_PythonLib) isTarget_Target()   {}
func (*Target_DockerImage) isTarget_Target() {}

func (m *Target) GetTarget() isTarget_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Target) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Target) GetDependencies() []*Dependency {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *Target) GetCommand() *CommandTarget {
	if x, ok := m.GetTarget().(*Target_Command); ok {
		return x.Command
	}
	return nil
}

func (m *Target) GetGoBinary() *GoBinaryTarget {
	if x, ok := m.GetTarget().(*Target_GoBinary); ok {
		return x.GoBinary
	}
	return nil
}

func (m *Target) GetPythonLib() *PythonLibTarget {
	if x, ok := m.GetTarget().(*Target_PythonLib); ok {
		return x.PythonLib
	}
	return nil
}

func (m *Target) GetDockerImage() *DockerImageTarget {
	if x, ok := m.GetTarget().(*Target_DockerImage); ok {
		return x.DockerImage
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Target) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Target_OneofMarshaler, _Target_OneofUnmarshaler, _Target_OneofSizer, []interface{}{
		(*Target_Command)(nil),
		(*Target_GoBinary)(nil),
		(*Target_PythonLib)(nil),
		(*Target_DockerImage)(nil),
	}
}

func _Target_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Target)
	// Target
	switch x := m.Target.(type) {
	case *Target_Command:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Command); err != nil {
			return err
		}
	case *Target_GoBinary:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GoBinary); err != nil {
			return err
		}
	case *Target_PythonLib:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PythonLib); err != nil {
			return err
		}
	case *Target_DockerImage:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DockerImage); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Target.Target has unexpected type %T", x)
	}
	return nil
}

func _Target_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Target)
	switch tag {
	case 5: // Target.command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_Command{msg}
		return true, err
	case 6: // Target.goBinary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoBinaryTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_GoBinary{msg}
		return true, err
	case 7: // Target.pythonLib
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PythonLibTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_PythonLib{msg}
		return true, err
	case 8: // Target.dockerImage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_DockerImage{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Target_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Target)
	// Target
	switch x := m.Target.(type) {
	case *Target_Command:
		s := proto.Size(x.Command)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_GoBinary:
		s := proto.Size(x.GoBinary)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_PythonLib:
		s := proto.Size(x.PythonLib)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_DockerImage:
		s := proto.Size(x.DockerImage)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Dependency
type Dependency struct {
	// Types that are valid to be assigned to Dependency:
	//	*Dependency_Target
	//	*Dependency_Go
	//	*Dependency_Pip
	Dependency isDependency_Dependency `protobuf_oneof:"Dependency"`
	// Options
	Options *DependencyOptions `protobuf:"bytes,15,opt,name=options" json:"options,omitempty"`
}

func (m *Dependency) Reset()                    { *m = Dependency{} }
func (m *Dependency) String() string            { return proto.CompactTextString(m) }
func (*Dependency) ProtoMessage()               {}
func (*Dependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isDependency_Dependency interface {
	isDependency_Dependency()
}

type Dependency_Target struct {
	Target *TargetDependency `protobuf:"bytes,1,opt,name=target,oneof"`
}
type Dependency_Go struct {
	Go *GoDependency `protobuf:"bytes,2,opt,name=go,oneof"`
}
type Dependency_Pip struct {
	Pip *PipDependency `protobuf:"bytes,3,opt,name=pip,oneof"`
}

func (*Dependency_Target) isDependency_Dependency() {}
func (*Dependency_Go) isDependency_Dependency()     {}
func (*Dependency_Pip) isDependency_Dependency()    {}

func (m *Dependency) GetDependency() isDependency_Dependency {
	if m != nil {
		return m.Dependency
	}
	return nil
}

func (m *Dependency) GetTarget() *TargetDependency {
	if x, ok := m.GetDependency().(*Dependency_Target); ok {
		return x.Target
	}
	return nil
}

func (m *Dependency) GetGo() *GoDependency {
	if x, ok := m.GetDependency().(*Dependency_Go); ok {
		return x.Go
	}
	return nil
}

func (m *Dependency) GetPip() *PipDependency {
	if x, ok := m.GetDependency().(*Dependency_Pip); ok {
		return x.Pip
	}
	return nil
}

func (m *Dependency) GetOptions() *DependencyOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Dependency) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Dependency_OneofMarshaler, _Dependency_OneofUnmarshaler, _Dependency_OneofSizer, []interface{}{
		(*Dependency_Target)(nil),
		(*Dependency_Go)(nil),
		(*Dependency_Pip)(nil),
	}
}

func _Dependency_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Dependency)
	// Dependency
	switch x := m.Dependency.(type) {
	case *Dependency_Target:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Target); err != nil {
			return err
		}
	case *Dependency_Go:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Go); err != nil {
			return err
		}
	case *Dependency_Pip:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pip); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Dependency.Dependency has unexpected type %T", x)
	}
	return nil
}

func _Dependency_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Dependency)
	switch tag {
	case 1: // Dependency.target
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TargetDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Target{msg}
		return true, err
	case 2: // Dependency.go
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Go{msg}
		return true, err
	case 3: // Dependency.pip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PipDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Pip{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Dependency_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Dependency)
	// Dependency
	switch x := m.Dependency.(type) {
	case *Dependency_Target:
		s := proto.Size(x.Target)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Dependency_Go:
		s := proto.Size(x.Go)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Dependency_Pip:
		s := proto.Size(x.Pip)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Dependency options
type DependencyOptions struct {
	// Build or not
	Build bool `protobuf:"varint,1,opt,name=build" json:"build,omitempty"`
}

func (m *DependencyOptions) Reset()                    { *m = DependencyOptions{} }
func (m *DependencyOptions) String() string            { return proto.CompactTextString(m) }
func (*DependencyOptions) ProtoMessage()               {}
func (*DependencyOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *DependencyOptions) GetBuild() bool {
	if m != nil {
		return m.Build
	}
	return false
}

// Target dependency
type TargetDependency struct {
	// Package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Target
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *TargetDependency) Reset()                    { *m = TargetDependency{} }
func (m *TargetDependency) String() string            { return proto.CompactTextString(m) }
func (*TargetDependency) ProtoMessage()               {}
func (*TargetDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *TargetDependency) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *TargetDependency) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

// Go dependency
type GoDependency struct {
	// Go package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
}

func (m *GoDependency) Reset()                    { *m = GoDependency{} }
func (m *GoDependency) String() string            { return proto.CompactTextString(m) }
func (*GoDependency) ProtoMessage()               {}
func (*GoDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *GoDependency) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

// Pip dependency
type PipDependency struct {
	// Pip module
	Module string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
}

func (m *PipDependency) Reset()                    { *m = PipDependency{} }
func (m *PipDependency) String() string            { return proto.CompactTextString(m) }
func (*PipDependency) ProtoMessage()               {}
func (*PipDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *PipDependency) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

// Command target
type CommandTarget struct {
	// Args
	Args []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
	// Work dir
	Workdir string `protobuf:"bytes,2,opt,name=workdir" json:"workdir,omitempty"`
	// Output dir
	Output string `protobuf:"bytes,3,opt,name=output" json:"output,omitempty"`
}

func (m *CommandTarget) Reset()                    { *m = CommandTarget{} }
func (m *CommandTarget) String() string            { return proto.CompactTextString(m) }
func (*CommandTarget) ProtoMessage()               {}
func (*CommandTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *CommandTarget) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandTarget) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *CommandTarget) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// Go bianry target
type GoBinaryTarget struct {
	// Package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Output name
	Output string `protobuf:"bytes,2,opt,name=output" json:"output,omitempty"`
}

func (m *GoBinaryTarget) Reset()                    { *m = GoBinaryTarget{} }
func (m *GoBinaryTarget) String() string            { return proto.CompactTextString(m) }
func (*GoBinaryTarget) ProtoMessage()               {}
func (*GoBinaryTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *GoBinaryTarget) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *GoBinaryTarget) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

// Python lib target
type PythonLibTarget struct {
	// Work dir
	Workdir string `protobuf:"bytes,1,opt,name=workdir" json:"workdir,omitempty"`
	// Setup filename
	Setup string `protobuf:"bytes,2,opt,name=setup" json:"setup,omitempty"`
}

func (m *PythonLibTarget) Reset()                    { *m = PythonLibTarget{} }
func (m *PythonLibTarget) String() string            { return proto.CompactTextString(m) }
func (*PythonLibTarget) ProtoMessage()               {}
func (*PythonLibTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *PythonLibTarget) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *PythonLibTarget) GetSetup() string {
	if m != nil {
		return m.Setup
	}
	return ""
}

// Docker image target
type DockerImageTarget struct {
	// Repository
	Repository string `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	// Image name
	ImageName string `protobuf:"bytes,2,opt,name=imageName" json:"imageName,omitempty"`
	// Commands
	Commands []*DockerImageBuildCommand `protobuf:"bytes,3,rep,name=commands" json:"commands,omitempty"`
}

func (m *DockerImageTarget) Reset()                    { *m = DockerImageTarget{} }
func (m *DockerImageTarget) String() string            { return proto.CompactTextString(m) }
func (*DockerImageTarget) ProtoMessage()               {}
func (*DockerImageTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *DockerImageTarget) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *DockerImageTarget) GetImageName() string {
	if m != nil {
		return m.ImageName
	}
	return ""
}

func (m *DockerImageTarget) GetCommands() []*DockerImageBuildCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

type DockerImageBuildCommand struct {
	// Command
	//
	// Types that are valid to be assigned to Command:
	//	*DockerImageBuildCommand_From_
	//	*DockerImageBuildCommand_Label_
	//	*DockerImageBuildCommand_Add_
	//	*DockerImageBuildCommand_Copy_
	//	*DockerImageBuildCommand_Run_
	//	*DockerImageBuildCommand_Entrypoint_
	//	*DockerImageBuildCommand_Expose_
	//	*DockerImageBuildCommand_Volume_
	//	*DockerImageBuildCommand_User_
	//	*DockerImageBuildCommand_Workdir_
	//	*DockerImageBuildCommand_Env_
	Command isDockerImageBuildCommand_Command `protobuf_oneof:"Command"`
}

func (m *DockerImageBuildCommand) Reset()                    { *m = DockerImageBuildCommand{} }
func (m *DockerImageBuildCommand) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand) ProtoMessage()               {}
func (*DockerImageBuildCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

type isDockerImageBuildCommand_Command interface {
	isDockerImageBuildCommand_Command()
}

type DockerImageBuildCommand_From_ struct {
	From *DockerImageBuildCommand_From `protobuf:"bytes,1,opt,name=from,oneof"`
}
type DockerImageBuildCommand_Label_ struct {
	Label *DockerImageBuildCommand_Label `protobuf:"bytes,2,opt,name=label,oneof"`
}
type DockerImageBuildCommand_Add_ struct {
	Add *DockerImageBuildCommand_Add `protobuf:"bytes,3,opt,name=add,oneof"`
}
type DockerImageBuildCommand_Copy_ struct {
	Copy *DockerImageBuildCommand_Copy `protobuf:"bytes,4,opt,name=copy,oneof"`
}
type DockerImageBuildCommand_Run_ struct {
	Run *DockerImageBuildCommand_Run `protobuf:"bytes,5,opt,name=run,oneof"`
}
type DockerImageBuildCommand_Entrypoint_ struct {
	Entrypoint *DockerImageBuildCommand_Entrypoint `protobuf:"bytes,6,opt,name=entrypoint,oneof"`
}
type DockerImageBuildCommand_Expose_ struct {
	Expose *DockerImageBuildCommand_Expose `protobuf:"bytes,7,opt,name=expose,oneof"`
}
type DockerImageBuildCommand_Volume_ struct {
	Volume *DockerImageBuildCommand_Volume `protobuf:"bytes,8,opt,name=volume,oneof"`
}
type DockerImageBuildCommand_User_ struct {
	User *DockerImageBuildCommand_User `protobuf:"bytes,9,opt,name=user,oneof"`
}
type DockerImageBuildCommand_Workdir_ struct {
	Workdir *DockerImageBuildCommand_Workdir `protobuf:"bytes,10,opt,name=workdir,oneof"`
}
type DockerImageBuildCommand_Env_ struct {
	Env *DockerImageBuildCommand_Env `protobuf:"bytes,11,opt,name=env,oneof"`
}

func (*DockerImageBuildCommand_From_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Label_) isDockerImageBuildCommand_Command()      {}
func (*DockerImageBuildCommand_Add_) isDockerImageBuildCommand_Command()        {}
func (*DockerImageBuildCommand_Copy_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Run_) isDockerImageBuildCommand_Command()        {}
func (*DockerImageBuildCommand_Entrypoint_) isDockerImageBuildCommand_Command() {}
func (*DockerImageBuildCommand_Expose_) isDockerImageBuildCommand_Command()     {}
func (*DockerImageBuildCommand_Volume_) isDockerImageBuildCommand_Command()     {}
func (*DockerImageBuildCommand_User_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Workdir_) isDockerImageBuildCommand_Command()    {}
func (*DockerImageBuildCommand_Env_) isDockerImageBuildCommand_Command()        {}

func (m *DockerImageBuildCommand) GetCommand() isDockerImageBuildCommand_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *DockerImageBuildCommand) GetFrom() *DockerImageBuildCommand_From {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_From_); ok {
		return x.From
	}
	return nil
}

func (m *DockerImageBuildCommand) GetLabel() *DockerImageBuildCommand_Label {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Label_); ok {
		return x.Label
	}
	return nil
}

func (m *DockerImageBuildCommand) GetAdd() *DockerImageBuildCommand_Add {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Add_); ok {
		return x.Add
	}
	return nil
}

func (m *DockerImageBuildCommand) GetCopy() *DockerImageBuildCommand_Copy {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Copy_); ok {
		return x.Copy
	}
	return nil
}

func (m *DockerImageBuildCommand) GetRun() *DockerImageBuildCommand_Run {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Run_); ok {
		return x.Run
	}
	return nil
}

func (m *DockerImageBuildCommand) GetEntrypoint() *DockerImageBuildCommand_Entrypoint {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Entrypoint_); ok {
		return x.Entrypoint
	}
	return nil
}

func (m *DockerImageBuildCommand) GetExpose() *DockerImageBuildCommand_Expose {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Expose_); ok {
		return x.Expose
	}
	return nil
}

func (m *DockerImageBuildCommand) GetVolume() *DockerImageBuildCommand_Volume {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Volume_); ok {
		return x.Volume
	}
	return nil
}

func (m *DockerImageBuildCommand) GetUser() *DockerImageBuildCommand_User {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_User_); ok {
		return x.User
	}
	return nil
}

func (m *DockerImageBuildCommand) GetWorkdir() *DockerImageBuildCommand_Workdir {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Workdir_); ok {
		return x.Workdir
	}
	return nil
}

func (m *DockerImageBuildCommand) GetEnv() *DockerImageBuildCommand_Env {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Env_); ok {
		return x.Env
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DockerImageBuildCommand) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DockerImageBuildCommand_OneofMarshaler, _DockerImageBuildCommand_OneofUnmarshaler, _DockerImageBuildCommand_OneofSizer, []interface{}{
		(*DockerImageBuildCommand_From_)(nil),
		(*DockerImageBuildCommand_Label_)(nil),
		(*DockerImageBuildCommand_Add_)(nil),
		(*DockerImageBuildCommand_Copy_)(nil),
		(*DockerImageBuildCommand_Run_)(nil),
		(*DockerImageBuildCommand_Entrypoint_)(nil),
		(*DockerImageBuildCommand_Expose_)(nil),
		(*DockerImageBuildCommand_Volume_)(nil),
		(*DockerImageBuildCommand_User_)(nil),
		(*DockerImageBuildCommand_Workdir_)(nil),
		(*DockerImageBuildCommand_Env_)(nil),
	}
}

func _DockerImageBuildCommand_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DockerImageBuildCommand)
	// Command
	switch x := m.Command.(type) {
	case *DockerImageBuildCommand_From_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.From); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Label_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Label); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Add_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Add); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Copy_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Copy); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Run_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Run); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Entrypoint_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Entrypoint); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Expose_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Expose); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Volume_:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Volume); err != nil {
			return err
		}
	case *DockerImageBuildCommand_User_:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.User); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Workdir_:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Workdir); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Env_:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Env); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DockerImageBuildCommand.Command has unexpected type %T", x)
	}
	return nil
}

func _DockerImageBuildCommand_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DockerImageBuildCommand)
	switch tag {
	case 1: // Command.from
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_From)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_From_{msg}
		return true, err
	case 2: // Command.label
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Label)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Label_{msg}
		return true, err
	case 3: // Command.add
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Add)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Add_{msg}
		return true, err
	case 4: // Command.copy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Copy)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Copy_{msg}
		return true, err
	case 5: // Command.run
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Run)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Run_{msg}
		return true, err
	case 6: // Command.entrypoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Entrypoint)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Entrypoint_{msg}
		return true, err
	case 7: // Command.expose
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Expose)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Expose_{msg}
		return true, err
	case 8: // Command.volume
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Volume)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Volume_{msg}
		return true, err
	case 9: // Command.user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_User)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_User_{msg}
		return true, err
	case 10: // Command.workdir
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Workdir)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Workdir_{msg}
		return true, err
	case 11: // Command.env
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Env)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Env_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DockerImageBuildCommand_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DockerImageBuildCommand)
	// Command
	switch x := m.Command.(type) {
	case *DockerImageBuildCommand_From_:
		s := proto.Size(x.From)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Label_:
		s := proto.Size(x.Label)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Add_:
		s := proto.Size(x.Add)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Copy_:
		s := proto.Size(x.Copy)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Run_:
		s := proto.Size(x.Run)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Entrypoint_:
		s := proto.Size(x.Entrypoint)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Expose_:
		s := proto.Size(x.Expose)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Volume_:
		s := proto.Size(x.Volume)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_User_:
		s := proto.Size(x.User)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Workdir_:
		s := proto.Size(x.Workdir)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Env_:
		s := proto.Size(x.Env)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// From command
type DockerImageBuildCommand_From struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DockerImageBuildCommand_From) Reset()         { *m = DockerImageBuildCommand_From{} }
func (m *DockerImageBuildCommand_From) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_From) ProtoMessage()    {}
func (*DockerImageBuildCommand_From) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 0}
}

func (m *DockerImageBuildCommand_From) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Label command
type DockerImageBuildCommand_Label struct {
	// Key
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *DockerImageBuildCommand_Label) Reset()         { *m = DockerImageBuildCommand_Label{} }
func (m *DockerImageBuildCommand_Label) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Label) ProtoMessage()    {}
func (*DockerImageBuildCommand_Label) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 1}
}

func (m *DockerImageBuildCommand_Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DockerImageBuildCommand_Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Add command
type DockerImageBuildCommand_Add struct {
	// File
	File *FileSource `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// Path
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Add) Reset()                    { *m = DockerImageBuildCommand_Add{} }
func (m *DockerImageBuildCommand_Add) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Add) ProtoMessage()               {}
func (*DockerImageBuildCommand_Add) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 2} }

func (m *DockerImageBuildCommand_Add) GetFile() *FileSource {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DockerImageBuildCommand_Add) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Copy command
type DockerImageBuildCommand_Copy struct {
	// File
	File *FileSource `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// Path
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Copy) Reset()         { *m = DockerImageBuildCommand_Copy{} }
func (m *DockerImageBuildCommand_Copy) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Copy) ProtoMessage()    {}
func (*DockerImageBuildCommand_Copy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 3}
}

func (m *DockerImageBuildCommand_Copy) GetFile() *FileSource {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DockerImageBuildCommand_Copy) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Run command
type DockerImageBuildCommand_Run struct {
	// Command
	Command string `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
}

func (m *DockerImageBuildCommand_Run) Reset()                    { *m = DockerImageBuildCommand_Run{} }
func (m *DockerImageBuildCommand_Run) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Run) ProtoMessage()               {}
func (*DockerImageBuildCommand_Run) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15, 4} }

func (m *DockerImageBuildCommand_Run) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

// Entrypoint command
type DockerImageBuildCommand_Entrypoint struct {
	// Args
	Args []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
}

func (m *DockerImageBuildCommand_Entrypoint) Reset()         { *m = DockerImageBuildCommand_Entrypoint{} }
func (m *DockerImageBuildCommand_Entrypoint) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Entrypoint) ProtoMessage()    {}
func (*DockerImageBuildCommand_Entrypoint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 5}
}

func (m *DockerImageBuildCommand_Entrypoint) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// Expose command
type DockerImageBuildCommand_Expose struct {
	// Ports
	Ports []int32 `protobuf:"varint,1,rep,packed,name=ports" json:"ports,omitempty"`
}

func (m *DockerImageBuildCommand_Expose) Reset()         { *m = DockerImageBuildCommand_Expose{} }
func (m *DockerImageBuildCommand_Expose) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Expose) ProtoMessage()    {}
func (*DockerImageBuildCommand_Expose) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 6}
}

func (m *DockerImageBuildCommand_Expose) GetPorts() []int32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Volume command
type DockerImageBuildCommand_Volume struct {
	// Paths
	Paths []string `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *DockerImageBuildCommand_Volume) Reset()         { *m = DockerImageBuildCommand_Volume{} }
func (m *DockerImageBuildCommand_Volume) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Volume) ProtoMessage()    {}
func (*DockerImageBuildCommand_Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 7}
}

func (m *DockerImageBuildCommand_Volume) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

// User command
type DockerImageBuildCommand_User struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DockerImageBuildCommand_User) Reset()         { *m = DockerImageBuildCommand_User{} }
func (m *DockerImageBuildCommand_User) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_User) ProtoMessage()    {}
func (*DockerImageBuildCommand_User) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 8}
}

func (m *DockerImageBuildCommand_User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Workdir command
type DockerImageBuildCommand_Workdir struct {
	// Path
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Workdir) Reset()         { *m = DockerImageBuildCommand_Workdir{} }
func (m *DockerImageBuildCommand_Workdir) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Workdir) ProtoMessage()    {}
func (*DockerImageBuildCommand_Workdir) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 9}
}

func (m *DockerImageBuildCommand_Workdir) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Env command
type DockerImageBuildCommand_Env struct {
	// Key
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *DockerImageBuildCommand_Env) Reset()         { *m = DockerImageBuildCommand_Env{} }
func (m *DockerImageBuildCommand_Env) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Env) ProtoMessage()    {}
func (*DockerImageBuildCommand_Env) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{15, 10}
}

func (m *DockerImageBuildCommand_Env) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DockerImageBuildCommand_Env) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// File source
type FileSource struct {
	// Source
	//
	// Types that are valid to be assigned to Source:
	//	*FileSource_File
	//	*FileSource_Artifact
	Source isFileSource_Source `protobuf_oneof:"Source"`
}

func (m *FileSource) Reset()                    { *m = FileSource{} }
func (m *FileSource) String() string            { return proto.CompactTextString(m) }
func (*FileSource) ProtoMessage()               {}
func (*FileSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type isFileSource_Source interface {
	isFileSource_Source()
}

type FileSource_File struct {
	File *File `protobuf:"bytes,1,opt,name=file,oneof"`
}
type FileSource_Artifact struct {
	Artifact *Artifact `protobuf:"bytes,2,opt,name=artifact,oneof"`
}

func (*FileSource_File) isFileSource_Source()     {}
func (*FileSource_Artifact) isFileSource_Source() {}

func (m *FileSource) GetSource() isFileSource_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *FileSource) GetFile() *File {
	if x, ok := m.GetSource().(*FileSource_File); ok {
		return x.File
	}
	return nil
}

func (m *FileSource) GetArtifact() *Artifact {
	if x, ok := m.GetSource().(*FileSource_Artifact); ok {
		return x.Artifact
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileSource_OneofMarshaler, _FileSource_OneofUnmarshaler, _FileSource_OneofSizer, []interface{}{
		(*FileSource_File)(nil),
		(*FileSource_Artifact)(nil),
	}
}

func _FileSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileSource)
	// Source
	switch x := m.Source.(type) {
	case *FileSource_File:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.File); err != nil {
			return err
		}
	case *FileSource_Artifact:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Artifact); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FileSource.Source has unexpected type %T", x)
	}
	return nil
}

func _FileSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileSource)
	switch tag {
	case 1: // Source.file
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(File)
		err := b.DecodeMessage(msg)
		m.Source = &FileSource_File{msg}
		return true, err
	case 2: // Source.artifact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Artifact)
		err := b.DecodeMessage(msg)
		m.Source = &FileSource_Artifact{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FileSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileSource)
	// Source
	switch x := m.Source.(type) {
	case *FileSource_File:
		s := proto.Size(x.File)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FileSource_Artifact:
		s := proto.Size(x.Artifact)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// File
type File struct {
	// Package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Filename
	Filename string `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *File) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *File) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

// Artifact
type Artifact struct {
	// Package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Target
	Target string `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
}

func (m *Artifact) Reset()                    { *m = Artifact{} }
func (m *Artifact) String() string            { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()               {}
func (*Artifact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Artifact) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *Artifact) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func init() {
	proto.RegisterType((*Package)(nil), "openlight.spec.Package")
	proto.RegisterType((*PackageOptions)(nil), "openlight.spec.PackageOptions")
	proto.RegisterType((*Reference)(nil), "openlight.spec.Reference")
	proto.RegisterType((*LocalFinder)(nil), "openlight.spec.LocalFinder")
	proto.RegisterType((*PythonLocalFinder)(nil), "openlight.spec.PythonLocalFinder")
	proto.RegisterType((*Target)(nil), "openlight.spec.Target")
	proto.RegisterType((*Dependency)(nil), "openlight.spec.Dependency")
	proto.RegisterType((*DependencyOptions)(nil), "openlight.spec.DependencyOptions")
	proto.RegisterType((*TargetDependency)(nil), "openlight.spec.TargetDependency")
	proto.RegisterType((*GoDependency)(nil), "openlight.spec.GoDependency")
	proto.RegisterType((*PipDependency)(nil), "openlight.spec.PipDependency")
	proto.RegisterType((*CommandTarget)(nil), "openlight.spec.CommandTarget")
	proto.RegisterType((*GoBinaryTarget)(nil), "openlight.spec.GoBinaryTarget")
	proto.RegisterType((*PythonLibTarget)(nil), "openlight.spec.PythonLibTarget")
	proto.RegisterType((*DockerImageTarget)(nil), "openlight.spec.DockerImageTarget")
	proto.RegisterType((*DockerImageBuildCommand)(nil), "openlight.spec.DockerImageBuildCommand")
	proto.RegisterType((*DockerImageBuildCommand_From)(nil), "openlight.spec.DockerImageBuildCommand.From")
	proto.RegisterType((*DockerImageBuildCommand_Label)(nil), "openlight.spec.DockerImageBuildCommand.Label")
	proto.RegisterType((*DockerImageBuildCommand_Add)(nil), "openlight.spec.DockerImageBuildCommand.Add")
	proto.RegisterType((*DockerImageBuildCommand_Copy)(nil), "openlight.spec.DockerImageBuildCommand.Copy")
	proto.RegisterType((*DockerImageBuildCommand_Run)(nil), "openlight.spec.DockerImageBuildCommand.Run")
	proto.RegisterType((*DockerImageBuildCommand_Entrypoint)(nil), "openlight.spec.DockerImageBuildCommand.Entrypoint")
	proto.RegisterType((*DockerImageBuildCommand_Expose)(nil), "openlight.spec.DockerImageBuildCommand.Expose")
	proto.RegisterType((*DockerImageBuildCommand_Volume)(nil), "openlight.spec.DockerImageBuildCommand.Volume")
	proto.RegisterType((*DockerImageBuildCommand_User)(nil), "openlight.spec.DockerImageBuildCommand.User")
	proto.RegisterType((*DockerImageBuildCommand_Workdir)(nil), "openlight.spec.DockerImageBuildCommand.Workdir")
	proto.RegisterType((*DockerImageBuildCommand_Env)(nil), "openlight.spec.DockerImageBuildCommand.Env")
	proto.RegisterType((*FileSource)(nil), "openlight.spec.FileSource")
	proto.RegisterType((*File)(nil), "openlight.spec.File")
	proto.RegisterType((*Artifact)(nil), "openlight.spec.Artifact")
}

func init() { proto.RegisterFile("spec/build.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1190 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x57, 0xdd, 0x6e, 0xdb, 0xb6,
	0x17, 0x8f, 0x2d, 0x7f, 0x1e, 0xa7, 0x69, 0x42, 0x04, 0xfd, 0xab, 0xfa, 0xb7, 0xa9, 0x2b, 0x0c,
	0x6b, 0xb6, 0xb5, 0x0e, 0x96, 0x01, 0x43, 0xd6, 0x06, 0x0d, 0xe2, 0xc4, 0xa9, 0xbb, 0x05, 0x5b,
	0xc0, 0xb5, 0xdb, 0xb0, 0x3b, 0x59, 0x62, 0x6c, 0x21, 0x32, 0x29, 0xd0, 0x92, 0x57, 0xef, 0x72,
	0x0f, 0xb1, 0x47, 0xd8, 0xab, 0xed, 0x0d, 0x76, 0x3d, 0xf0, 0x43, 0xb2, 0xa4, 0xc8, 0x85, 0x03,
	0xec, 0x4e, 0x87, 0x3c, 0xbf, 0x1f, 0xcf, 0x37, 0x29, 0xd8, 0x9e, 0x85, 0xc4, 0x3d, 0x18, 0xc5,
	0x7e, 0xe0, 0xf5, 0x42, 0xce, 0x22, 0x86, 0xb6, 0x58, 0x48, 0x68, 0xe0, 0x8f, 0x27, 0x51, 0x4f,
	0xec, 0xd9, 0x7f, 0x19, 0xd0, 0xbc, 0x72, 0xdc, 0x1b, 0x67, 0x4c, 0x10, 0x82, 0x1a, 0x75, 0xa6,
	0xc4, 0xac, 0x74, 0x2b, 0xfb, 0x6d, 0x2c, 0xbf, 0xd1, 0x03, 0x68, 0x70, 0x32, 0x65, 0x11, 0x31,
	0xab, 0x72, 0x55, 0x4b, 0xe8, 0x0d, 0x00, 0x27, 0xd7, 0x84, 0x13, 0xea, 0x92, 0x99, 0x69, 0x74,
	0x8d, 0xfd, 0xce, 0xe1, 0xb3, 0x5e, 0x9e, 0xbc, 0xa7, 0x89, 0x7b, 0x38, 0xd5, 0x1c, 0xd0, 0x88,
	0x2f, 0x70, 0x06, 0x8a, 0x5e, 0x43, 0x33, 0x72, 0xf8, 0x98, 0x44, 0x33, 0xb3, 0x26, 0x59, 0x3e,
	0x59, 0xc5, 0xf2, 0x4e, 0xa9, 0x29, 0x8a, 0x04, 0x84, 0x8e, 0xa0, 0xc9, 0xc2, 0xc8, 0x67, 0x74,
	0x66, 0xde, 0xef, 0x56, 0xf6, 0x3b, 0x87, 0x7b, 0x2b, 0xf0, 0x3f, 0x28, 0x2d, 0x9c, 0xa8, 0x5b,
	0xbf, 0xc0, 0xfd, 0x82, 0x61, 0x68, 0x1b, 0x8c, 0x1b, 0xb2, 0xd0, 0x01, 0x10, 0x9f, 0xe8, 0x00,
	0xea, 0x73, 0x27, 0x88, 0x95, 0xfb, 0x9d, 0xc3, 0x87, 0x45, 0xf2, 0x94, 0x01, 0x2b, 0xbd, 0x97,
	0xd5, 0xa3, 0x8a, 0x85, 0x61, 0x33, 0x6b, 0x6c, 0x09, 0xed, 0xf3, 0x3c, 0xed, 0x83, 0x22, 0xad,
	0x82, 0x67, 0x38, 0xed, 0x23, 0xd8, 0xca, 0x3b, 0x82, 0x3e, 0x85, 0x2d, 0x8f, 0x5c, 0x3b, 0x71,
	0x10, 0xe9, 0xc3, 0xcc, 0x4a, 0xd7, 0xd8, 0x6f, 0xe3, 0xc2, 0xaa, 0xfd, 0x01, 0xda, 0xa9, 0x95,
	0x77, 0xca, 0xf1, 0x09, 0x6c, 0x06, 0xcc, 0x75, 0x82, 0x0b, 0x9f, 0x7a, 0x84, 0x27, 0x59, 0xfe,
	0x7f, 0xd1, 0xd6, 0xcb, 0xa5, 0x0e, 0xce, 0x01, 0xec, 0x09, 0x74, 0x32, 0x9b, 0xa5, 0x67, 0xbf,
	0x82, 0x46, 0xb8, 0x88, 0x26, 0x8c, 0xea, 0x48, 0x3c, 0xbd, 0x95, 0x3d, 0xb9, 0x9b, 0xa1, 0x19,
	0x6e, 0x60, 0x0d, 0xe9, 0xb7, 0xa0, 0xa1, 0xd6, 0xec, 0x33, 0xd8, 0xb9, 0xa5, 0x28, 0xfc, 0x9a,
	0x32, 0x2f, 0x0e, 0x92, 0x13, 0xb5, 0x24, 0xd6, 0x43, 0x87, 0x13, 0x1a, 0xc9, 0x33, 0xeb, 0x58,
	0x4b, 0xf6, 0xdf, 0x55, 0x68, 0xa8, 0xa0, 0x95, 0x9a, 0xfa, 0x1a, 0x36, 0x3d, 0x12, 0x12, 0xea,
	0x11, 0xea, 0xfa, 0x64, 0x66, 0x56, 0x65, 0x38, 0xac, 0xa2, 0xc1, 0xe7, 0x89, 0xce, 0x02, 0xe7,
	0xf4, 0xd1, 0x37, 0xd0, 0x74, 0xd9, 0x74, 0xea, 0x50, 0xcf, 0xac, 0x4b, 0x5f, 0x1f, 0x17, 0xa1,
	0x67, 0x6a, 0x5b, 0xd9, 0x30, 0xdc, 0xc0, 0x89, 0x3e, 0x3a, 0x86, 0xd6, 0x98, 0xf5, 0x7d, 0xea,
	0xf0, 0x85, 0xd9, 0x28, 0xaf, 0xf2, 0x37, 0x7a, 0x3f, 0x05, 0xa7, 0x08, 0x74, 0x02, 0x6d, 0x15,
	0xb0, 0x4b, 0x7f, 0x64, 0x36, 0x25, 0xfc, 0xc9, 0x8a, 0x30, 0xfb, 0xa3, 0x14, 0xbf, 0xc4, 0xa0,
	0x01, 0x74, 0x3c, 0xe6, 0xde, 0x10, 0xfe, 0x76, 0xea, 0x8c, 0x89, 0xd9, 0x2a, 0xcf, 0xd4, 0xf9,
	0x52, 0x25, 0x25, 0xc9, 0xe2, 0x44, 0xba, 0xd4, 0x86, 0xfd, 0x4f, 0x05, 0x60, 0x19, 0x27, 0xf4,
	0x12, 0x1a, 0xaa, 0x9d, 0x65, 0xbc, 0x3b, 0x87, 0xdd, 0xf2, 0x76, 0x58, 0x22, 0x44, 0x0d, 0x28,
	0x04, 0xea, 0x41, 0x75, 0xcc, 0x74, 0xf1, 0x3c, 0xba, 0x1d, 0x94, 0x1c, 0xa6, 0x3a, 0x66, 0xe8,
	0x4b, 0x30, 0x42, 0x3f, 0x34, 0x8d, 0xf2, 0x0c, 0x5c, 0xf9, 0x61, 0x0e, 0x21, 0x74, 0xd1, 0xab,
	0xe2, 0x88, 0x79, 0xba, 0x3a, 0xe7, 0xc5, 0x29, 0xd3, 0xdf, 0xcc, 0x7a, 0x6a, 0x7f, 0x06, 0x3b,
	0xb7, 0x74, 0xd1, 0x2e, 0xd4, 0xe5, 0x88, 0x96, 0xde, 0xb7, 0xb0, 0x12, 0xec, 0x73, 0xd8, 0x2e,
	0xba, 0x8d, 0x4c, 0x68, 0x86, 0x6a, 0x08, 0xe8, 0xca, 0x4c, 0x44, 0x51, 0xd3, 0x3a, 0x84, 0xba,
	0x87, 0x95, 0x64, 0xef, 0xc3, 0x66, 0x36, 0x08, 0xab, 0x19, 0xec, 0x67, 0x70, 0x2f, 0xe7, 0xfd,
	0xaa, 0xf6, 0xb1, 0xdf, 0xc3, 0xbd, 0x5c, 0xa1, 0x8a, 0x66, 0x71, 0xf8, 0x38, 0x19, 0x3f, 0xf2,
	0x5b, 0x9c, 0xf3, 0x1b, 0xe3, 0x37, 0x9e, 0xcf, 0xb5, 0x41, 0x89, 0x28, 0x68, 0x59, 0x1c, 0x85,
	0x71, 0x24, 0x73, 0xd0, 0xc6, 0x5a, 0xb2, 0xfb, 0xb0, 0x95, 0xaf, 0xe1, 0x8f, 0x7b, 0xab, 0x39,
	0xaa, 0x39, 0x8e, 0x53, 0xb8, 0x5f, 0x28, 0xe4, 0xac, 0x21, 0x95, 0xbc, 0x21, 0xbb, 0x50, 0x9f,
	0x91, 0x28, 0x0e, 0x35, 0x87, 0x12, 0xec, 0x3f, 0x2b, 0xb0, 0x73, 0xab, 0x92, 0xd1, 0x9e, 0xb8,
	0xee, 0x42, 0x36, 0xf3, 0x23, 0xc6, 0x93, 0x41, 0x9e, 0x59, 0x41, 0x8f, 0xa0, 0xed, 0x0b, 0xf5,
	0xef, 0xc5, 0xd0, 0x50, 0x7c, 0xcb, 0x05, 0x74, 0x06, 0x2d, 0xdd, 0xc9, 0x2b, 0xaf, 0xca, 0xcc,
	0x91, 0x7d, 0x91, 0x7e, 0x1d, 0x61, 0x9c, 0x02, 0xed, 0x3f, 0x00, 0xfe, 0xb7, 0x42, 0x0b, 0xf5,
	0xa1, 0x76, 0xcd, 0xd9, 0x54, 0xb7, 0xcf, 0xf3, 0x35, 0xc9, 0x7b, 0x17, 0x9c, 0x4d, 0x87, 0x1b,
	0x58, 0x62, 0xd1, 0x00, 0xea, 0x81, 0x33, 0x22, 0x81, 0xee, 0xa5, 0x17, 0xeb, 0x92, 0x5c, 0x0a,
	0xd0, 0x70, 0x03, 0x2b, 0x34, 0x3a, 0x01, 0xc3, 0xf1, 0x3c, 0xdd, 0x5f, 0x5f, 0xac, 0x4b, 0x72,
	0xea, 0x79, 0xa2, 0xdb, 0x1c, 0x4f, 0xfa, 0xe2, 0xb2, 0x70, 0x61, 0xd6, 0xee, 0xe6, 0xcb, 0x19,
	0x0b, 0x45, 0xc3, 0x4a, 0xac, 0x30, 0x82, 0xc7, 0x54, 0x8f, 0xd9, 0xb5, 0x8d, 0xc0, 0x31, 0x15,
	0x46, 0xf0, 0x98, 0xa2, 0x77, 0x00, 0x44, 0x5c, 0xdd, 0x21, 0xf3, 0x69, 0xa4, 0x47, 0xee, 0xe1,
	0xba, 0x3c, 0x83, 0x14, 0x39, 0xdc, 0xc0, 0x19, 0x1e, 0x34, 0x84, 0x06, 0xf9, 0x10, 0xb2, 0x19,
	0xd1, 0x53, 0xb8, 0xb7, 0x36, 0xa3, 0x44, 0x89, 0xa9, 0xa7, 0xf0, 0x82, 0x69, 0xce, 0x82, 0x78,
	0x9a, 0x0c, 0xe3, 0xb5, 0x99, 0x7e, 0x92, 0x28, 0xc1, 0xa4, 0xf0, 0x22, 0xdc, 0xf1, 0x8c, 0x70,
	0xb3, 0x7d, 0xb7, 0x70, 0xbf, 0x9f, 0xc9, 0x9b, 0x58, 0x62, 0xd1, 0x77, 0xcb, 0x1e, 0x03, 0x49,
	0x73, 0xb0, 0x2e, 0xcd, 0xcf, 0x0a, 0x26, 0xee, 0xba, 0xa4, 0x2d, 0x4f, 0xc0, 0x20, 0x74, 0x6e,
	0x76, 0xee, 0x96, 0xbb, 0x01, 0x9d, 0x8b, 0xdc, 0x11, 0x3a, 0xb7, 0x2c, 0xa8, 0x89, 0xc2, 0x2e,
	0xbb, 0xc3, 0xad, 0x03, 0xa8, 0xcb, 0x7a, 0x2d, 0x79, 0x92, 0xed, 0x66, 0x9f, 0x64, 0x6d, 0xfd,
	0xf4, 0xb2, 0xde, 0x82, 0x71, 0xea, 0x79, 0xa8, 0x07, 0xb5, 0x6b, 0x5f, 0x4f, 0xc2, 0x92, 0x3b,
	0xff, 0xc2, 0x0f, 0xc8, 0x8f, 0x2c, 0xe6, 0x2e, 0xc1, 0x52, 0x4f, 0x9c, 0x1d, 0x3a, 0xd1, 0x44,
	0x73, 0xc9, 0x6f, 0xeb, 0x5b, 0xa8, 0x89, 0x22, 0xfd, 0x4f, 0xb8, 0x9e, 0x80, 0x81, 0x63, 0x2a,
	0x86, 0x5b, 0xf2, 0xa4, 0xd0, 0xc3, 0x4d, 0x8b, 0x56, 0x17, 0x60, 0x59, 0x86, 0x65, 0x13, 0xda,
	0xda, 0x83, 0x86, 0x2a, 0x2b, 0xe1, 0x79, 0xc8, 0xb8, 0x7e, 0x3f, 0xd6, 0xb1, 0x12, 0xc4, 0xbe,
	0x2a, 0x16, 0xb9, 0xef, 0x44, 0x93, 0x04, 0xae, 0x04, 0x11, 0x66, 0x51, 0x04, 0xa5, 0x61, 0x7e,
	0x0c, 0x4d, 0x9d, 0xd9, 0xd4, 0xfa, 0x4a, 0xc6, 0xfa, 0x17, 0x60, 0x0c, 0xe8, 0x7c, 0xdd, 0x1c,
	0xf4, 0xdb, 0xd0, 0xd4, 0x69, 0xb6, 0x7f, 0x07, 0x58, 0xc6, 0x07, 0x7d, 0x9e, 0x8b, 0xe4, 0x6e,
	0x59, 0x24, 0xe5, 0x78, 0x13, 0x51, 0xfc, 0x1a, 0x5a, 0x0e, 0x8f, 0xfc, 0x6b, 0xc7, 0x8d, 0xf4,
	0x84, 0x33, 0x8b, 0xfa, 0xa7, 0x7a, 0x5f, 0x3c, 0x9e, 0x12, 0x5d, 0xf1, 0x68, 0x51, 0xa7, 0xd9,
	0xc7, 0x50, 0x13, 0x8c, 0x1f, 0xb9, 0x96, 0x2c, 0x68, 0x89, 0xb3, 0xe8, 0xf2, 0x12, 0x48, 0x65,
	0xfb, 0x18, 0x5a, 0x09, 0xff, 0xdd, 0xaf, 0xf1, 0xfe, 0x01, 0x3c, 0x74, 0xd9, 0xb4, 0x37, 0xf6,
	0xa3, 0x49, 0x3c, 0x2a, 0xd8, 0xdd, 0x07, 0xd9, 0x09, 0x57, 0xe2, 0xff, 0xee, 0xaa, 0xf2, 0x6b,
	0x4d, 0xac, 0x8d, 0x1a, 0xf2, 0x77, 0xef, 0xab, 0x7f, 0x03, 0x00, 0x00, 0xff, 0xff, 0x8d, 0x37,
	0xfd, 0x59, 0x02, 0x0e, 0x00, 0x00,
}
