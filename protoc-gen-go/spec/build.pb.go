// Code generated by protoc-gen-go. DO NOT EDIT.
// source: spec/build.proto

/*
Package spec is a generated protocol buffer package.

It is generated from these files:
	spec/build.proto
	spec/runner.proto
	spec/rule.proto

It has these top-level messages:
	BuildFile
	Package
	PackageOptions
	Reference
	Finder
	PythonFinder
	GoFinder
	Target
	Dependency
	TargetDependency
	GoDependency
	PipDependency
	CommandTarget
	GoBinaryTarget
	PythonLibTarget
	DockerImageTarget
	DockerImageBuildCommand
	FileSource
	File
	Artifact
	RunFile
	RunCommand
	RunProcess
	RunProcessState
	RunProcessLog
	RuleFiles
*/
package spec

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// The build file
type BuildFile struct {
	// The package
	Package *Package `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
}

func (m *BuildFile) Reset()                    { *m = BuildFile{} }
func (m *BuildFile) String() string            { return proto.CompactTextString(m) }
func (*BuildFile) ProtoMessage()               {}
func (*BuildFile) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *BuildFile) GetPackage() *Package {
	if m != nil {
		return m.Package
	}
	return nil
}

// Package
type Package struct {
	// Package name for display
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Package meta info
	Meta map[string]string `protobuf:"bytes,2,rep,name=meta" json:"meta,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Targets
	Targets map[string]*Target `protobuf:"bytes,3,rep,name=targets" json:"targets,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// References
	References map[string]*Reference `protobuf:"bytes,4,rep,name=references" json:"references,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	// Options
	Options *PackageOptions `protobuf:"bytes,15,opt,name=options" json:"options,omitempty"`
}

func (m *Package) Reset()                    { *m = Package{} }
func (m *Package) String() string            { return proto.CompactTextString(m) }
func (*Package) ProtoMessage()               {}
func (*Package) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Package) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Package) GetMeta() map[string]string {
	if m != nil {
		return m.Meta
	}
	return nil
}

func (m *Package) GetTargets() map[string]*Target {
	if m != nil {
		return m.Targets
	}
	return nil
}

func (m *Package) GetReferences() map[string]*Reference {
	if m != nil {
		return m.References
	}
	return nil
}

func (m *Package) GetOptions() *PackageOptions {
	if m != nil {
		return m.Options
	}
	return nil
}

// Package options
type PackageOptions struct {
	// Default targets (to build)
	DefaultTargets []string `protobuf:"bytes,1,rep,name=defaultTargets" json:"defaultTargets,omitempty"`
}

func (m *PackageOptions) Reset()                    { *m = PackageOptions{} }
func (m *PackageOptions) String() string            { return proto.CompactTextString(m) }
func (*PackageOptions) ProtoMessage()               {}
func (*PackageOptions) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *PackageOptions) GetDefaultTargets() []string {
	if m != nil {
		return m.DefaultTargets
	}
	return nil
}

// Reference (package)
type Reference struct {
	// Remote (Git address)
	Remote string `protobuf:"bytes,1,opt,name=remote" json:"remote,omitempty"`
	// Finders (To find the referenced repository, before clone the repository from remote)
	Finders []*Finder `protobuf:"bytes,2,rep,name=finders" json:"finders,omitempty"`
	// Path to the root of the found / cloned repository.
	// Set this attribute will allow `change the root` of a repository
	Path string `protobuf:"bytes,3,opt,name=path" json:"path,omitempty"`
}

func (m *Reference) Reset()                    { *m = Reference{} }
func (m *Reference) String() string            { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()               {}
func (*Reference) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Reference) GetRemote() string {
	if m != nil {
		return m.Remote
	}
	return ""
}

func (m *Reference) GetFinders() []*Finder {
	if m != nil {
		return m.Finders
	}
	return nil
}

func (m *Reference) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Repository finder
type Finder struct {
	// Finder name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
	// Finders
	//
	// Types that are valid to be assigned to Finder:
	//	*Finder_Python
	//	*Finder_Go
	Finder isFinder_Finder `protobuf_oneof:"Finder"`
}

func (m *Finder) Reset()                    { *m = Finder{} }
func (m *Finder) String() string            { return proto.CompactTextString(m) }
func (*Finder) ProtoMessage()               {}
func (*Finder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type isFinder_Finder interface {
	isFinder_Finder()
}

type Finder_Python struct {
	Python *PythonFinder `protobuf:"bytes,2,opt,name=python,oneof"`
}
type Finder_Go struct {
	Go *GoFinder `protobuf:"bytes,3,opt,name=go,oneof"`
}

func (*Finder_Python) isFinder_Finder() {}
func (*Finder_Go) isFinder_Finder()     {}

func (m *Finder) GetFinder() isFinder_Finder {
	if m != nil {
		return m.Finder
	}
	return nil
}

func (m *Finder) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Finder) GetPython() *PythonFinder {
	if x, ok := m.GetFinder().(*Finder_Python); ok {
		return x.Python
	}
	return nil
}

func (m *Finder) GetGo() *GoFinder {
	if x, ok := m.GetFinder().(*Finder_Go); ok {
		return x.Go
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Finder) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Finder_OneofMarshaler, _Finder_OneofUnmarshaler, _Finder_OneofSizer, []interface{}{
		(*Finder_Python)(nil),
		(*Finder_Go)(nil),
	}
}

func _Finder_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Finder)
	// Finder
	switch x := m.Finder.(type) {
	case *Finder_Python:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Python); err != nil {
			return err
		}
	case *Finder_Go:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Go); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Finder.Finder has unexpected type %T", x)
	}
	return nil
}

func _Finder_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Finder)
	switch tag {
	case 2: // Finder.python
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PythonFinder)
		err := b.DecodeMessage(msg)
		m.Finder = &Finder_Python{msg}
		return true, err
	case 3: // Finder.go
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoFinder)
		err := b.DecodeMessage(msg)
		m.Finder = &Finder_Go{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Finder_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Finder)
	// Finder
	switch x := m.Finder.(type) {
	case *Finder_Python:
		s := proto.Size(x.Python)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Finder_Go:
		s := proto.Size(x.Go)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Python finder
type PythonFinder struct {
	// Python module name
	Module string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
	// The number of parent dirs
	Parent int32 `protobuf:"varint,2,opt,name=parent" json:"parent,omitempty"`
}

func (m *PythonFinder) Reset()                    { *m = PythonFinder{} }
func (m *PythonFinder) String() string            { return proto.CompactTextString(m) }
func (*PythonFinder) ProtoMessage()               {}
func (*PythonFinder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PythonFinder) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

func (m *PythonFinder) GetParent() int32 {
	if m != nil {
		return m.Parent
	}
	return 0
}

// Go finder
type GoFinder struct {
	// Go package name
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Go root path
	Root string `protobuf:"bytes,2,opt,name=root" json:"root,omitempty"`
	// The number of parent dirs
	Parent int32 `protobuf:"varint,3,opt,name=parent" json:"parent,omitempty"`
}

func (m *GoFinder) Reset()                    { *m = GoFinder{} }
func (m *GoFinder) String() string            { return proto.CompactTextString(m) }
func (*GoFinder) ProtoMessage()               {}
func (*GoFinder) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GoFinder) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *GoFinder) GetRoot() string {
	if m != nil {
		return m.Root
	}
	return ""
}

func (m *GoFinder) GetParent() int32 {
	if m != nil {
		return m.Parent
	}
	return 0
}

// Target
type Target struct {
	// Description
	Description string `protobuf:"bytes,1,opt,name=description" json:"description,omitempty"`
	// Dependencies
	Dependencies []*Dependency `protobuf:"bytes,2,rep,name=dependencies" json:"dependencies,omitempty"`
	// Target
	//
	// Types that are valid to be assigned to Target:
	//	*Target_Command
	//	*Target_GoBinary
	//	*Target_PythonLib
	//	*Target_DockerImage
	Target isTarget_Target `protobuf_oneof:"Target"`
}

func (m *Target) Reset()                    { *m = Target{} }
func (m *Target) String() string            { return proto.CompactTextString(m) }
func (*Target) ProtoMessage()               {}
func (*Target) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

type isTarget_Target interface {
	isTarget_Target()
}

type Target_Command struct {
	Command *CommandTarget `protobuf:"bytes,5,opt,name=command,oneof"`
}
type Target_GoBinary struct {
	GoBinary *GoBinaryTarget `protobuf:"bytes,6,opt,name=goBinary,oneof"`
}
type Target_PythonLib struct {
	PythonLib *PythonLibTarget `protobuf:"bytes,7,opt,name=pythonLib,oneof"`
}
type Target_DockerImage struct {
	DockerImage *DockerImageTarget `protobuf:"bytes,8,opt,name=dockerImage,oneof"`
}

func (*Target_Command) isTarget_Target()     {}
func (*Target_GoBinary) isTarget_Target()    {}
func (*Target_PythonLib) isTarget_Target()   {}
func (*Target_DockerImage) isTarget_Target() {}

func (m *Target) GetTarget() isTarget_Target {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Target) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Target) GetDependencies() []*Dependency {
	if m != nil {
		return m.Dependencies
	}
	return nil
}

func (m *Target) GetCommand() *CommandTarget {
	if x, ok := m.GetTarget().(*Target_Command); ok {
		return x.Command
	}
	return nil
}

func (m *Target) GetGoBinary() *GoBinaryTarget {
	if x, ok := m.GetTarget().(*Target_GoBinary); ok {
		return x.GoBinary
	}
	return nil
}

func (m *Target) GetPythonLib() *PythonLibTarget {
	if x, ok := m.GetTarget().(*Target_PythonLib); ok {
		return x.PythonLib
	}
	return nil
}

func (m *Target) GetDockerImage() *DockerImageTarget {
	if x, ok := m.GetTarget().(*Target_DockerImage); ok {
		return x.DockerImage
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Target) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Target_OneofMarshaler, _Target_OneofUnmarshaler, _Target_OneofSizer, []interface{}{
		(*Target_Command)(nil),
		(*Target_GoBinary)(nil),
		(*Target_PythonLib)(nil),
		(*Target_DockerImage)(nil),
	}
}

func _Target_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Target)
	// Target
	switch x := m.Target.(type) {
	case *Target_Command:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Command); err != nil {
			return err
		}
	case *Target_GoBinary:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.GoBinary); err != nil {
			return err
		}
	case *Target_PythonLib:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.PythonLib); err != nil {
			return err
		}
	case *Target_DockerImage:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.DockerImage); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Target.Target has unexpected type %T", x)
	}
	return nil
}

func _Target_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Target)
	switch tag {
	case 5: // Target.command
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(CommandTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_Command{msg}
		return true, err
	case 6: // Target.goBinary
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoBinaryTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_GoBinary{msg}
		return true, err
	case 7: // Target.pythonLib
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PythonLibTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_PythonLib{msg}
		return true, err
	case 8: // Target.dockerImage
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageTarget)
		err := b.DecodeMessage(msg)
		m.Target = &Target_DockerImage{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Target_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Target)
	// Target
	switch x := m.Target.(type) {
	case *Target_Command:
		s := proto.Size(x.Command)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_GoBinary:
		s := proto.Size(x.GoBinary)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_PythonLib:
		s := proto.Size(x.PythonLib)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Target_DockerImage:
		s := proto.Size(x.DockerImage)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Dependency
type Dependency struct {
	// Types that are valid to be assigned to Dependency:
	//	*Dependency_Target
	//	*Dependency_Go
	//	*Dependency_Pip
	Dependency isDependency_Dependency `protobuf_oneof:"Dependency"`
}

func (m *Dependency) Reset()                    { *m = Dependency{} }
func (m *Dependency) String() string            { return proto.CompactTextString(m) }
func (*Dependency) ProtoMessage()               {}
func (*Dependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

type isDependency_Dependency interface {
	isDependency_Dependency()
}

type Dependency_Target struct {
	Target *TargetDependency `protobuf:"bytes,1,opt,name=target,oneof"`
}
type Dependency_Go struct {
	Go *GoDependency `protobuf:"bytes,2,opt,name=go,oneof"`
}
type Dependency_Pip struct {
	Pip *PipDependency `protobuf:"bytes,3,opt,name=pip,oneof"`
}

func (*Dependency_Target) isDependency_Dependency() {}
func (*Dependency_Go) isDependency_Dependency()     {}
func (*Dependency_Pip) isDependency_Dependency()    {}

func (m *Dependency) GetDependency() isDependency_Dependency {
	if m != nil {
		return m.Dependency
	}
	return nil
}

func (m *Dependency) GetTarget() *TargetDependency {
	if x, ok := m.GetDependency().(*Dependency_Target); ok {
		return x.Target
	}
	return nil
}

func (m *Dependency) GetGo() *GoDependency {
	if x, ok := m.GetDependency().(*Dependency_Go); ok {
		return x.Go
	}
	return nil
}

func (m *Dependency) GetPip() *PipDependency {
	if x, ok := m.GetDependency().(*Dependency_Pip); ok {
		return x.Pip
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Dependency) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Dependency_OneofMarshaler, _Dependency_OneofUnmarshaler, _Dependency_OneofSizer, []interface{}{
		(*Dependency_Target)(nil),
		(*Dependency_Go)(nil),
		(*Dependency_Pip)(nil),
	}
}

func _Dependency_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Dependency)
	// Dependency
	switch x := m.Dependency.(type) {
	case *Dependency_Target:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Target); err != nil {
			return err
		}
	case *Dependency_Go:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Go); err != nil {
			return err
		}
	case *Dependency_Pip:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Pip); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Dependency.Dependency has unexpected type %T", x)
	}
	return nil
}

func _Dependency_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Dependency)
	switch tag {
	case 1: // Dependency.target
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(TargetDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Target{msg}
		return true, err
	case 2: // Dependency.go
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(GoDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Go{msg}
		return true, err
	case 3: // Dependency.pip
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(PipDependency)
		err := b.DecodeMessage(msg)
		m.Dependency = &Dependency_Pip{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Dependency_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Dependency)
	// Dependency
	switch x := m.Dependency.(type) {
	case *Dependency_Target:
		s := proto.Size(x.Target)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Dependency_Go:
		s := proto.Size(x.Go)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Dependency_Pip:
		s := proto.Size(x.Pip)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// Target dependency
type TargetDependency struct {
	// Reference name. Empty means the package itself
	Reference string `protobuf:"bytes,1,opt,name=reference" json:"reference,omitempty"`
	// Path. Empty means the root path in the reference
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Target
	Target string `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	// Build or not
	Build bool `protobuf:"varint,10,opt,name=build" json:"build,omitempty"`
}

func (m *TargetDependency) Reset()                    { *m = TargetDependency{} }
func (m *TargetDependency) String() string            { return proto.CompactTextString(m) }
func (*TargetDependency) ProtoMessage()               {}
func (*TargetDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *TargetDependency) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

func (m *TargetDependency) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *TargetDependency) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *TargetDependency) GetBuild() bool {
	if m != nil {
		return m.Build
	}
	return false
}

// Go dependency
type GoDependency struct {
	// Go package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
}

func (m *GoDependency) Reset()                    { *m = GoDependency{} }
func (m *GoDependency) String() string            { return proto.CompactTextString(m) }
func (*GoDependency) ProtoMessage()               {}
func (*GoDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *GoDependency) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

// Pip dependency
type PipDependency struct {
	// Pip module
	Module string `protobuf:"bytes,1,opt,name=module" json:"module,omitempty"`
}

func (m *PipDependency) Reset()                    { *m = PipDependency{} }
func (m *PipDependency) String() string            { return proto.CompactTextString(m) }
func (*PipDependency) ProtoMessage()               {}
func (*PipDependency) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *PipDependency) GetModule() string {
	if m != nil {
		return m.Module
	}
	return ""
}

// Command target
type CommandTarget struct {
	// Command
	Command string `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
	// Args
	Args []string `protobuf:"bytes,2,rep,name=args" json:"args,omitempty"`
	// Work dir
	Workdir string `protobuf:"bytes,3,opt,name=workdir" json:"workdir,omitempty"`
	// The environments
	Envs []string `protobuf:"bytes,4,rep,name=envs" json:"envs,omitempty"`
}

func (m *CommandTarget) Reset()                    { *m = CommandTarget{} }
func (m *CommandTarget) String() string            { return proto.CompactTextString(m) }
func (*CommandTarget) ProtoMessage()               {}
func (*CommandTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *CommandTarget) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

func (m *CommandTarget) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

func (m *CommandTarget) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *CommandTarget) GetEnvs() []string {
	if m != nil {
		return m.Envs
	}
	return nil
}

// Go bianry target
type GoBinaryTarget struct {
	// Package
	Package string `protobuf:"bytes,1,opt,name=package" json:"package,omitempty"`
	// Output name
	Output string `protobuf:"bytes,2,opt,name=output" json:"output,omitempty"`
	// Install the binary or not
	Install bool `protobuf:"varint,3,opt,name=install" json:"install,omitempty"`
	// Environ variables. Always used to do cross compiling
	Envs []string `protobuf:"bytes,4,rep,name=envs" json:"envs,omitempty"`
}

func (m *GoBinaryTarget) Reset()                    { *m = GoBinaryTarget{} }
func (m *GoBinaryTarget) String() string            { return proto.CompactTextString(m) }
func (*GoBinaryTarget) ProtoMessage()               {}
func (*GoBinaryTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *GoBinaryTarget) GetPackage() string {
	if m != nil {
		return m.Package
	}
	return ""
}

func (m *GoBinaryTarget) GetOutput() string {
	if m != nil {
		return m.Output
	}
	return ""
}

func (m *GoBinaryTarget) GetInstall() bool {
	if m != nil {
		return m.Install
	}
	return false
}

func (m *GoBinaryTarget) GetEnvs() []string {
	if m != nil {
		return m.Envs
	}
	return nil
}

// Python lib target
type PythonLibTarget struct {
	// Work dir (relative to package path)
	Workdir string `protobuf:"bytes,1,opt,name=workdir" json:"workdir,omitempty"`
	// Setup filename
	Setup string `protobuf:"bytes,2,opt,name=setup" json:"setup,omitempty"`
}

func (m *PythonLibTarget) Reset()                    { *m = PythonLibTarget{} }
func (m *PythonLibTarget) String() string            { return proto.CompactTextString(m) }
func (*PythonLibTarget) ProtoMessage()               {}
func (*PythonLibTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *PythonLibTarget) GetWorkdir() string {
	if m != nil {
		return m.Workdir
	}
	return ""
}

func (m *PythonLibTarget) GetSetup() string {
	if m != nil {
		return m.Setup
	}
	return ""
}

// Docker image target
type DockerImageTarget struct {
	// Repository
	Repository string `protobuf:"bytes,1,opt,name=repository" json:"repository,omitempty"`
	// Image name
	Image string `protobuf:"bytes,2,opt,name=image" json:"image,omitempty"`
	// Commands
	Commands []*DockerImageBuildCommand `protobuf:"bytes,3,rep,name=commands" json:"commands,omitempty"`
	// Push or not
	Push bool `protobuf:"varint,4,opt,name=push" json:"push,omitempty"`
	// Set the `latest` tag
	SetLatestTag bool `protobuf:"varint,5,opt,name=setLatestTag" json:"setLatestTag,omitempty"`
}

func (m *DockerImageTarget) Reset()                    { *m = DockerImageTarget{} }
func (m *DockerImageTarget) String() string            { return proto.CompactTextString(m) }
func (*DockerImageTarget) ProtoMessage()               {}
func (*DockerImageTarget) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *DockerImageTarget) GetRepository() string {
	if m != nil {
		return m.Repository
	}
	return ""
}

func (m *DockerImageTarget) GetImage() string {
	if m != nil {
		return m.Image
	}
	return ""
}

func (m *DockerImageTarget) GetCommands() []*DockerImageBuildCommand {
	if m != nil {
		return m.Commands
	}
	return nil
}

func (m *DockerImageTarget) GetPush() bool {
	if m != nil {
		return m.Push
	}
	return false
}

func (m *DockerImageTarget) GetSetLatestTag() bool {
	if m != nil {
		return m.SetLatestTag
	}
	return false
}

type DockerImageBuildCommand struct {
	// Command
	//
	// Types that are valid to be assigned to Command:
	//	*DockerImageBuildCommand_From_
	//	*DockerImageBuildCommand_Label_
	//	*DockerImageBuildCommand_Add_
	//	*DockerImageBuildCommand_Copy_
	//	*DockerImageBuildCommand_Run_
	//	*DockerImageBuildCommand_Entrypoint_
	//	*DockerImageBuildCommand_Expose_
	//	*DockerImageBuildCommand_Volume_
	//	*DockerImageBuildCommand_User_
	//	*DockerImageBuildCommand_Workdir_
	//	*DockerImageBuildCommand_Env_
	Command isDockerImageBuildCommand_Command `protobuf_oneof:"Command"`
}

func (m *DockerImageBuildCommand) Reset()                    { *m = DockerImageBuildCommand{} }
func (m *DockerImageBuildCommand) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand) ProtoMessage()               {}
func (*DockerImageBuildCommand) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

type isDockerImageBuildCommand_Command interface {
	isDockerImageBuildCommand_Command()
}

type DockerImageBuildCommand_From_ struct {
	From *DockerImageBuildCommand_From `protobuf:"bytes,1,opt,name=from,oneof"`
}
type DockerImageBuildCommand_Label_ struct {
	Label *DockerImageBuildCommand_Label `protobuf:"bytes,2,opt,name=label,oneof"`
}
type DockerImageBuildCommand_Add_ struct {
	Add *DockerImageBuildCommand_Add `protobuf:"bytes,3,opt,name=add,oneof"`
}
type DockerImageBuildCommand_Copy_ struct {
	Copy *DockerImageBuildCommand_Copy `protobuf:"bytes,4,opt,name=copy,oneof"`
}
type DockerImageBuildCommand_Run_ struct {
	Run *DockerImageBuildCommand_Run `protobuf:"bytes,5,opt,name=run,oneof"`
}
type DockerImageBuildCommand_Entrypoint_ struct {
	Entrypoint *DockerImageBuildCommand_Entrypoint `protobuf:"bytes,6,opt,name=entrypoint,oneof"`
}
type DockerImageBuildCommand_Expose_ struct {
	Expose *DockerImageBuildCommand_Expose `protobuf:"bytes,7,opt,name=expose,oneof"`
}
type DockerImageBuildCommand_Volume_ struct {
	Volume *DockerImageBuildCommand_Volume `protobuf:"bytes,8,opt,name=volume,oneof"`
}
type DockerImageBuildCommand_User_ struct {
	User *DockerImageBuildCommand_User `protobuf:"bytes,9,opt,name=user,oneof"`
}
type DockerImageBuildCommand_Workdir_ struct {
	Workdir *DockerImageBuildCommand_Workdir `protobuf:"bytes,10,opt,name=workdir,oneof"`
}
type DockerImageBuildCommand_Env_ struct {
	Env *DockerImageBuildCommand_Env `protobuf:"bytes,11,opt,name=env,oneof"`
}

func (*DockerImageBuildCommand_From_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Label_) isDockerImageBuildCommand_Command()      {}
func (*DockerImageBuildCommand_Add_) isDockerImageBuildCommand_Command()        {}
func (*DockerImageBuildCommand_Copy_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Run_) isDockerImageBuildCommand_Command()        {}
func (*DockerImageBuildCommand_Entrypoint_) isDockerImageBuildCommand_Command() {}
func (*DockerImageBuildCommand_Expose_) isDockerImageBuildCommand_Command()     {}
func (*DockerImageBuildCommand_Volume_) isDockerImageBuildCommand_Command()     {}
func (*DockerImageBuildCommand_User_) isDockerImageBuildCommand_Command()       {}
func (*DockerImageBuildCommand_Workdir_) isDockerImageBuildCommand_Command()    {}
func (*DockerImageBuildCommand_Env_) isDockerImageBuildCommand_Command()        {}

func (m *DockerImageBuildCommand) GetCommand() isDockerImageBuildCommand_Command {
	if m != nil {
		return m.Command
	}
	return nil
}

func (m *DockerImageBuildCommand) GetFrom() *DockerImageBuildCommand_From {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_From_); ok {
		return x.From
	}
	return nil
}

func (m *DockerImageBuildCommand) GetLabel() *DockerImageBuildCommand_Label {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Label_); ok {
		return x.Label
	}
	return nil
}

func (m *DockerImageBuildCommand) GetAdd() *DockerImageBuildCommand_Add {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Add_); ok {
		return x.Add
	}
	return nil
}

func (m *DockerImageBuildCommand) GetCopy() *DockerImageBuildCommand_Copy {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Copy_); ok {
		return x.Copy
	}
	return nil
}

func (m *DockerImageBuildCommand) GetRun() *DockerImageBuildCommand_Run {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Run_); ok {
		return x.Run
	}
	return nil
}

func (m *DockerImageBuildCommand) GetEntrypoint() *DockerImageBuildCommand_Entrypoint {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Entrypoint_); ok {
		return x.Entrypoint
	}
	return nil
}

func (m *DockerImageBuildCommand) GetExpose() *DockerImageBuildCommand_Expose {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Expose_); ok {
		return x.Expose
	}
	return nil
}

func (m *DockerImageBuildCommand) GetVolume() *DockerImageBuildCommand_Volume {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Volume_); ok {
		return x.Volume
	}
	return nil
}

func (m *DockerImageBuildCommand) GetUser() *DockerImageBuildCommand_User {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_User_); ok {
		return x.User
	}
	return nil
}

func (m *DockerImageBuildCommand) GetWorkdir() *DockerImageBuildCommand_Workdir {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Workdir_); ok {
		return x.Workdir
	}
	return nil
}

func (m *DockerImageBuildCommand) GetEnv() *DockerImageBuildCommand_Env {
	if x, ok := m.GetCommand().(*DockerImageBuildCommand_Env_); ok {
		return x.Env
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*DockerImageBuildCommand) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _DockerImageBuildCommand_OneofMarshaler, _DockerImageBuildCommand_OneofUnmarshaler, _DockerImageBuildCommand_OneofSizer, []interface{}{
		(*DockerImageBuildCommand_From_)(nil),
		(*DockerImageBuildCommand_Label_)(nil),
		(*DockerImageBuildCommand_Add_)(nil),
		(*DockerImageBuildCommand_Copy_)(nil),
		(*DockerImageBuildCommand_Run_)(nil),
		(*DockerImageBuildCommand_Entrypoint_)(nil),
		(*DockerImageBuildCommand_Expose_)(nil),
		(*DockerImageBuildCommand_Volume_)(nil),
		(*DockerImageBuildCommand_User_)(nil),
		(*DockerImageBuildCommand_Workdir_)(nil),
		(*DockerImageBuildCommand_Env_)(nil),
	}
}

func _DockerImageBuildCommand_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*DockerImageBuildCommand)
	// Command
	switch x := m.Command.(type) {
	case *DockerImageBuildCommand_From_:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.From); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Label_:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Label); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Add_:
		b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Add); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Copy_:
		b.EncodeVarint(4<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Copy); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Run_:
		b.EncodeVarint(5<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Run); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Entrypoint_:
		b.EncodeVarint(6<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Entrypoint); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Expose_:
		b.EncodeVarint(7<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Expose); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Volume_:
		b.EncodeVarint(8<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Volume); err != nil {
			return err
		}
	case *DockerImageBuildCommand_User_:
		b.EncodeVarint(9<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.User); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Workdir_:
		b.EncodeVarint(10<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Workdir); err != nil {
			return err
		}
	case *DockerImageBuildCommand_Env_:
		b.EncodeVarint(11<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Env); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("DockerImageBuildCommand.Command has unexpected type %T", x)
	}
	return nil
}

func _DockerImageBuildCommand_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*DockerImageBuildCommand)
	switch tag {
	case 1: // Command.from
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_From)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_From_{msg}
		return true, err
	case 2: // Command.label
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Label)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Label_{msg}
		return true, err
	case 3: // Command.add
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Add)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Add_{msg}
		return true, err
	case 4: // Command.copy
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Copy)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Copy_{msg}
		return true, err
	case 5: // Command.run
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Run)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Run_{msg}
		return true, err
	case 6: // Command.entrypoint
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Entrypoint)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Entrypoint_{msg}
		return true, err
	case 7: // Command.expose
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Expose)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Expose_{msg}
		return true, err
	case 8: // Command.volume
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Volume)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Volume_{msg}
		return true, err
	case 9: // Command.user
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_User)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_User_{msg}
		return true, err
	case 10: // Command.workdir
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Workdir)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Workdir_{msg}
		return true, err
	case 11: // Command.env
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(DockerImageBuildCommand_Env)
		err := b.DecodeMessage(msg)
		m.Command = &DockerImageBuildCommand_Env_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _DockerImageBuildCommand_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*DockerImageBuildCommand)
	// Command
	switch x := m.Command.(type) {
	case *DockerImageBuildCommand_From_:
		s := proto.Size(x.From)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Label_:
		s := proto.Size(x.Label)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Add_:
		s := proto.Size(x.Add)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Copy_:
		s := proto.Size(x.Copy)
		n += proto.SizeVarint(4<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Run_:
		s := proto.Size(x.Run)
		n += proto.SizeVarint(5<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Entrypoint_:
		s := proto.Size(x.Entrypoint)
		n += proto.SizeVarint(6<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Expose_:
		s := proto.Size(x.Expose)
		n += proto.SizeVarint(7<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Volume_:
		s := proto.Size(x.Volume)
		n += proto.SizeVarint(8<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_User_:
		s := proto.Size(x.User)
		n += proto.SizeVarint(9<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Workdir_:
		s := proto.Size(x.Workdir)
		n += proto.SizeVarint(10<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *DockerImageBuildCommand_Env_:
		s := proto.Size(x.Env)
		n += proto.SizeVarint(11<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// From command
type DockerImageBuildCommand_From struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DockerImageBuildCommand_From) Reset()         { *m = DockerImageBuildCommand_From{} }
func (m *DockerImageBuildCommand_From) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_From) ProtoMessage()    {}
func (*DockerImageBuildCommand_From) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 0}
}

func (m *DockerImageBuildCommand_From) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Label command
type DockerImageBuildCommand_Label struct {
	// Key
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *DockerImageBuildCommand_Label) Reset()         { *m = DockerImageBuildCommand_Label{} }
func (m *DockerImageBuildCommand_Label) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Label) ProtoMessage()    {}
func (*DockerImageBuildCommand_Label) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 1}
}

func (m *DockerImageBuildCommand_Label) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DockerImageBuildCommand_Label) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Add command
type DockerImageBuildCommand_Add struct {
	// File
	File *FileSource `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// Path
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Add) Reset()                    { *m = DockerImageBuildCommand_Add{} }
func (m *DockerImageBuildCommand_Add) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Add) ProtoMessage()               {}
func (*DockerImageBuildCommand_Add) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 2} }

func (m *DockerImageBuildCommand_Add) GetFile() *FileSource {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DockerImageBuildCommand_Add) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Copy command
type DockerImageBuildCommand_Copy struct {
	// File
	File *FileSource `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// Path
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Copy) Reset()         { *m = DockerImageBuildCommand_Copy{} }
func (m *DockerImageBuildCommand_Copy) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Copy) ProtoMessage()    {}
func (*DockerImageBuildCommand_Copy) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 3}
}

func (m *DockerImageBuildCommand_Copy) GetFile() *FileSource {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *DockerImageBuildCommand_Copy) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Run command
type DockerImageBuildCommand_Run struct {
	// Command
	Command string `protobuf:"bytes,1,opt,name=command" json:"command,omitempty"`
}

func (m *DockerImageBuildCommand_Run) Reset()                    { *m = DockerImageBuildCommand_Run{} }
func (m *DockerImageBuildCommand_Run) String() string            { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Run) ProtoMessage()               {}
func (*DockerImageBuildCommand_Run) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16, 4} }

func (m *DockerImageBuildCommand_Run) GetCommand() string {
	if m != nil {
		return m.Command
	}
	return ""
}

// Entrypoint command
type DockerImageBuildCommand_Entrypoint struct {
	// Args
	Args []string `protobuf:"bytes,1,rep,name=args" json:"args,omitempty"`
}

func (m *DockerImageBuildCommand_Entrypoint) Reset()         { *m = DockerImageBuildCommand_Entrypoint{} }
func (m *DockerImageBuildCommand_Entrypoint) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Entrypoint) ProtoMessage()    {}
func (*DockerImageBuildCommand_Entrypoint) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 5}
}

func (m *DockerImageBuildCommand_Entrypoint) GetArgs() []string {
	if m != nil {
		return m.Args
	}
	return nil
}

// Expose command
type DockerImageBuildCommand_Expose struct {
	// Ports
	Ports []int32 `protobuf:"varint,1,rep,packed,name=ports" json:"ports,omitempty"`
}

func (m *DockerImageBuildCommand_Expose) Reset()         { *m = DockerImageBuildCommand_Expose{} }
func (m *DockerImageBuildCommand_Expose) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Expose) ProtoMessage()    {}
func (*DockerImageBuildCommand_Expose) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 6}
}

func (m *DockerImageBuildCommand_Expose) GetPorts() []int32 {
	if m != nil {
		return m.Ports
	}
	return nil
}

// Volume command
type DockerImageBuildCommand_Volume struct {
	// Paths
	Paths []string `protobuf:"bytes,1,rep,name=paths" json:"paths,omitempty"`
}

func (m *DockerImageBuildCommand_Volume) Reset()         { *m = DockerImageBuildCommand_Volume{} }
func (m *DockerImageBuildCommand_Volume) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Volume) ProtoMessage()    {}
func (*DockerImageBuildCommand_Volume) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 7}
}

func (m *DockerImageBuildCommand_Volume) GetPaths() []string {
	if m != nil {
		return m.Paths
	}
	return nil
}

// User command
type DockerImageBuildCommand_User struct {
	// Name
	Name string `protobuf:"bytes,1,opt,name=name" json:"name,omitempty"`
}

func (m *DockerImageBuildCommand_User) Reset()         { *m = DockerImageBuildCommand_User{} }
func (m *DockerImageBuildCommand_User) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_User) ProtoMessage()    {}
func (*DockerImageBuildCommand_User) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 8}
}

func (m *DockerImageBuildCommand_User) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

// Workdir command
type DockerImageBuildCommand_Workdir struct {
	// Path
	Path string `protobuf:"bytes,1,opt,name=path" json:"path,omitempty"`
}

func (m *DockerImageBuildCommand_Workdir) Reset()         { *m = DockerImageBuildCommand_Workdir{} }
func (m *DockerImageBuildCommand_Workdir) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Workdir) ProtoMessage()    {}
func (*DockerImageBuildCommand_Workdir) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 9}
}

func (m *DockerImageBuildCommand_Workdir) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

// Env command
type DockerImageBuildCommand_Env struct {
	// Key
	Key string `protobuf:"bytes,1,opt,name=key" json:"key,omitempty"`
	// Value
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
}

func (m *DockerImageBuildCommand_Env) Reset()         { *m = DockerImageBuildCommand_Env{} }
func (m *DockerImageBuildCommand_Env) String() string { return proto.CompactTextString(m) }
func (*DockerImageBuildCommand_Env) ProtoMessage()    {}
func (*DockerImageBuildCommand_Env) Descriptor() ([]byte, []int) {
	return fileDescriptor0, []int{16, 10}
}

func (m *DockerImageBuildCommand_Env) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *DockerImageBuildCommand_Env) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// File source
type FileSource struct {
	// Source
	//
	// Types that are valid to be assigned to Source:
	//	*FileSource_File
	//	*FileSource_Artifact
	Source isFileSource_Source `protobuf_oneof:"Source"`
}

func (m *FileSource) Reset()                    { *m = FileSource{} }
func (m *FileSource) String() string            { return proto.CompactTextString(m) }
func (*FileSource) ProtoMessage()               {}
func (*FileSource) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

type isFileSource_Source interface {
	isFileSource_Source()
}

type FileSource_File struct {
	File *File `protobuf:"bytes,1,opt,name=file,oneof"`
}
type FileSource_Artifact struct {
	Artifact *Artifact `protobuf:"bytes,2,opt,name=artifact,oneof"`
}

func (*FileSource_File) isFileSource_Source()     {}
func (*FileSource_Artifact) isFileSource_Source() {}

func (m *FileSource) GetSource() isFileSource_Source {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *FileSource) GetFile() *File {
	if x, ok := m.GetSource().(*FileSource_File); ok {
		return x.File
	}
	return nil
}

func (m *FileSource) GetArtifact() *Artifact {
	if x, ok := m.GetSource().(*FileSource_Artifact); ok {
		return x.Artifact
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*FileSource) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _FileSource_OneofMarshaler, _FileSource_OneofUnmarshaler, _FileSource_OneofSizer, []interface{}{
		(*FileSource_File)(nil),
		(*FileSource_Artifact)(nil),
	}
}

func _FileSource_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*FileSource)
	// Source
	switch x := m.Source.(type) {
	case *FileSource_File:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.File); err != nil {
			return err
		}
	case *FileSource_Artifact:
		b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Artifact); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("FileSource.Source has unexpected type %T", x)
	}
	return nil
}

func _FileSource_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*FileSource)
	switch tag {
	case 1: // Source.file
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(File)
		err := b.DecodeMessage(msg)
		m.Source = &FileSource_File{msg}
		return true, err
	case 2: // Source.artifact
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Artifact)
		err := b.DecodeMessage(msg)
		m.Source = &FileSource_Artifact{msg}
		return true, err
	default:
		return false, nil
	}
}

func _FileSource_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*FileSource)
	// Source
	switch x := m.Source.(type) {
	case *FileSource_File:
		s := proto.Size(x.File)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *FileSource_Artifact:
		s := proto.Size(x.Artifact)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

// File
type File struct {
	// Reference. Empty means the package itself.
	Reference string `protobuf:"bytes,1,opt,name=reference" json:"reference,omitempty"`
	// File names.
	Filename string `protobuf:"bytes,2,opt,name=filename" json:"filename,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *File) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

func (m *File) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

// Artifact
type Artifact struct {
	// Reference. Empty means the package itself.
	Reference string `protobuf:"bytes,1,opt,name=reference" json:"reference,omitempty"`
	// Path (in repository for finding target)
	Path string `protobuf:"bytes,2,opt,name=path" json:"path,omitempty"`
	// Target
	Target string `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	// Filename in artifact
	Filename string `protobuf:"bytes,4,opt,name=filename" json:"filename,omitempty"`
}

func (m *Artifact) Reset()                    { *m = Artifact{} }
func (m *Artifact) String() string            { return proto.CompactTextString(m) }
func (*Artifact) ProtoMessage()               {}
func (*Artifact) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *Artifact) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

func (m *Artifact) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

func (m *Artifact) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *Artifact) GetFilename() string {
	if m != nil {
		return m.Filename
	}
	return ""
}

func init() {
	proto.RegisterType((*BuildFile)(nil), "openlight.spec.BuildFile")
	proto.RegisterType((*Package)(nil), "openlight.spec.Package")
	proto.RegisterType((*PackageOptions)(nil), "openlight.spec.PackageOptions")
	proto.RegisterType((*Reference)(nil), "openlight.spec.Reference")
	proto.RegisterType((*Finder)(nil), "openlight.spec.Finder")
	proto.RegisterType((*PythonFinder)(nil), "openlight.spec.PythonFinder")
	proto.RegisterType((*GoFinder)(nil), "openlight.spec.GoFinder")
	proto.RegisterType((*Target)(nil), "openlight.spec.Target")
	proto.RegisterType((*Dependency)(nil), "openlight.spec.Dependency")
	proto.RegisterType((*TargetDependency)(nil), "openlight.spec.TargetDependency")
	proto.RegisterType((*GoDependency)(nil), "openlight.spec.GoDependency")
	proto.RegisterType((*PipDependency)(nil), "openlight.spec.PipDependency")
	proto.RegisterType((*CommandTarget)(nil), "openlight.spec.CommandTarget")
	proto.RegisterType((*GoBinaryTarget)(nil), "openlight.spec.GoBinaryTarget")
	proto.RegisterType((*PythonLibTarget)(nil), "openlight.spec.PythonLibTarget")
	proto.RegisterType((*DockerImageTarget)(nil), "openlight.spec.DockerImageTarget")
	proto.RegisterType((*DockerImageBuildCommand)(nil), "openlight.spec.DockerImageBuildCommand")
	proto.RegisterType((*DockerImageBuildCommand_From)(nil), "openlight.spec.DockerImageBuildCommand.From")
	proto.RegisterType((*DockerImageBuildCommand_Label)(nil), "openlight.spec.DockerImageBuildCommand.Label")
	proto.RegisterType((*DockerImageBuildCommand_Add)(nil), "openlight.spec.DockerImageBuildCommand.Add")
	proto.RegisterType((*DockerImageBuildCommand_Copy)(nil), "openlight.spec.DockerImageBuildCommand.Copy")
	proto.RegisterType((*DockerImageBuildCommand_Run)(nil), "openlight.spec.DockerImageBuildCommand.Run")
	proto.RegisterType((*DockerImageBuildCommand_Entrypoint)(nil), "openlight.spec.DockerImageBuildCommand.Entrypoint")
	proto.RegisterType((*DockerImageBuildCommand_Expose)(nil), "openlight.spec.DockerImageBuildCommand.Expose")
	proto.RegisterType((*DockerImageBuildCommand_Volume)(nil), "openlight.spec.DockerImageBuildCommand.Volume")
	proto.RegisterType((*DockerImageBuildCommand_User)(nil), "openlight.spec.DockerImageBuildCommand.User")
	proto.RegisterType((*DockerImageBuildCommand_Workdir)(nil), "openlight.spec.DockerImageBuildCommand.Workdir")
	proto.RegisterType((*DockerImageBuildCommand_Env)(nil), "openlight.spec.DockerImageBuildCommand.Env")
	proto.RegisterType((*FileSource)(nil), "openlight.spec.FileSource")
	proto.RegisterType((*File)(nil), "openlight.spec.File")
	proto.RegisterType((*Artifact)(nil), "openlight.spec.Artifact")
}

func init() { proto.RegisterFile("spec/build.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1331 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x57, 0x5d, 0x6f, 0xdc, 0x44,
	0x17, 0x8e, 0xd7, 0xde, 0x0f, 0x9f, 0x4d, 0xd3, 0xbe, 0xa3, 0xa8, 0x75, 0xad, 0x7e, 0xec, 0x6b,
	0x21, 0x1a, 0x95, 0x76, 0x43, 0x83, 0x28, 0xa5, 0x42, 0x29, 0xd9, 0x36, 0x4d, 0x0a, 0x41, 0x44,
	0x43, 0xa1, 0x88, 0x3b, 0x67, 0x3d, 0xd9, 0x58, 0xf1, 0x7a, 0xac, 0xf1, 0x78, 0x61, 0xb9, 0xe4,
	0x92, 0x7f, 0xc4, 0x1f, 0xe0, 0x1f, 0x71, 0x8b, 0xd0, 0x7c, 0x79, 0xed, 0xfd, 0xa8, 0x36, 0x52,
	0xef, 0x3c, 0x33, 0xe7, 0x79, 0xe6, 0x9c, 0x33, 0xcf, 0x39, 0x33, 0x86, 0x1b, 0x79, 0x46, 0x86,
	0xbb, 0x67, 0x45, 0x9c, 0x44, 0xfd, 0x8c, 0x51, 0x4e, 0xd1, 0x16, 0xcd, 0x48, 0x9a, 0xc4, 0xa3,
	0x0b, 0xde, 0x17, 0x6b, 0xc1, 0x3e, 0xb8, 0x03, 0xb1, 0xfc, 0x3a, 0x4e, 0x08, 0x7a, 0x02, 0xed,
	0x2c, 0x1c, 0x5e, 0x86, 0x23, 0xe2, 0x59, 0x3d, 0x6b, 0xa7, 0xbb, 0x77, 0xab, 0x5f, 0x37, 0xef,
	0x9f, 0xaa, 0x65, 0x6c, 0xec, 0x82, 0x7f, 0x6d, 0x68, 0xeb, 0x49, 0x84, 0xc0, 0x49, 0xc3, 0xb1,
	0xc2, 0xba, 0x58, 0x7e, 0xa3, 0xcf, 0xc1, 0x19, 0x13, 0x1e, 0x7a, 0x8d, 0x9e, 0xbd, 0xd3, 0xdd,
	0xfb, 0xff, 0x0a, 0xbe, 0xfe, 0x77, 0x84, 0x87, 0x87, 0x29, 0x67, 0x53, 0x2c, 0xcd, 0xd1, 0x3e,
	0xb4, 0x79, 0xc8, 0x46, 0x84, 0xe7, 0x9e, 0x2d, 0x91, 0x1f, 0xad, 0x42, 0xbe, 0x55, 0x66, 0x0a,
	0x6c, 0x40, 0xe8, 0x08, 0x80, 0x91, 0x73, 0xc2, 0x48, 0x3a, 0x24, 0xb9, 0xe7, 0x48, 0x8a, 0x07,
	0xab, 0x28, 0x70, 0x69, 0xa9, 0x58, 0x2a, 0x50, 0xf4, 0x0c, 0xda, 0x34, 0xe3, 0x31, 0x4d, 0x73,
	0xef, 0xba, 0x4c, 0xc9, 0xbd, 0x15, 0x2c, 0xdf, 0x2b, 0x2b, 0x6c, 0xcc, 0xfd, 0x2f, 0xc0, 0x2d,
	0xa3, 0x42, 0x37, 0xc0, 0xbe, 0x24, 0x53, 0x9d, 0x19, 0xf1, 0x89, 0xb6, 0xa1, 0x39, 0x09, 0x93,
	0x82, 0x78, 0x0d, 0x39, 0xa7, 0x06, 0xcf, 0x1b, 0xcf, 0x2c, 0x1f, 0xc3, 0x66, 0x35, 0xa8, 0x25,
	0xd8, 0x47, 0x55, 0x6c, 0x77, 0xef, 0xe6, 0xbc, 0x4b, 0x0a, 0x5e, 0xe5, 0xfc, 0x19, 0xae, 0xcf,
	0x45, 0xb9, 0x84, 0x76, 0xb7, 0x4e, 0x7b, 0x7b, 0x9e, 0xb6, 0x64, 0xa8, 0x30, 0x07, 0xcf, 0x60,
	0xab, 0x9e, 0x01, 0xf4, 0x31, 0x6c, 0x45, 0xe4, 0x3c, 0x2c, 0x12, 0xae, 0xc3, 0xf0, 0xac, 0x9e,
	0xbd, 0xe3, 0xe2, 0xb9, 0xd9, 0x20, 0x06, 0xb7, 0x64, 0x44, 0x37, 0xa1, 0xc5, 0xc8, 0x98, 0x72,
	0xa3, 0x1e, 0x3d, 0x42, 0x9f, 0x42, 0xfb, 0x3c, 0x4e, 0x23, 0xc2, 0x72, 0x2d, 0xa1, 0x85, 0x60,
	0x5f, 0xcb, 0x65, 0x6c, 0xcc, 0x84, 0x0a, 0xb3, 0x90, 0x5f, 0x78, 0xb6, 0x52, 0xa1, 0xf8, 0x0e,
	0xfe, 0xb4, 0xa0, 0xa5, 0xec, 0x96, 0x8a, 0xf4, 0x29, 0xb4, 0xb2, 0x29, 0xbf, 0xa0, 0xa9, 0x8e,
	0xfc, 0xce, 0xc2, 0x19, 0xcb, 0x55, 0xc5, 0x70, 0xbc, 0x81, 0xb5, 0x35, 0x7a, 0x08, 0x8d, 0x11,
	0x95, 0x1b, 0x75, 0xf7, 0xbc, 0x79, 0xcc, 0x11, 0x2d, 0xed, 0x1b, 0x23, 0x3a, 0xe8, 0x18, 0x0f,
	0x82, 0x7d, 0xd8, 0xac, 0xf2, 0x89, 0xd0, 0xc7, 0x34, 0x2a, 0x92, 0x32, 0x74, 0x35, 0x12, 0xf3,
	0x59, 0xc8, 0x48, 0xca, 0xa5, 0x57, 0x4d, 0xac, 0x47, 0xc1, 0x29, 0x74, 0x0c, 0x37, 0xf2, 0xea,
	0x15, 0xeb, 0x96, 0x85, 0x29, 0xe2, 0x64, 0x94, 0x72, 0x2d, 0x2f, 0xf9, 0x5d, 0x61, 0xb4, 0x6b,
	0x8c, 0xff, 0x34, 0xa0, 0xa5, 0x4e, 0x05, 0xf5, 0xa0, 0x1b, 0x91, 0x7c, 0xc8, 0x62, 0x79, 0x98,
	0x9a, 0xb4, 0x3a, 0x85, 0xf6, 0x61, 0x33, 0x22, 0x19, 0x49, 0x23, 0x92, 0x0e, 0x63, 0x62, 0x8e,
	0xc5, 0x9f, 0x0f, 0xff, 0x95, 0xb1, 0x99, 0xe2, 0x9a, 0x3d, 0xfa, 0x12, 0xda, 0x43, 0x3a, 0x1e,
	0x87, 0x69, 0xe4, 0x35, 0x65, 0xe6, 0xee, 0xce, 0x43, 0x5f, 0xaa, 0x65, 0xe5, 0xd1, 0xf1, 0x06,
	0x36, 0xf6, 0xe8, 0x2b, 0xe8, 0x8c, 0xe8, 0x20, 0x4e, 0x43, 0x36, 0xf5, 0x5a, 0xcb, 0xab, 0xf1,
	0x48, 0xaf, 0x97, 0xe0, 0x12, 0x81, 0x5e, 0x80, 0xab, 0xce, 0xed, 0x24, 0x3e, 0xf3, 0xda, 0x12,
	0x7e, 0x7f, 0xf9, 0x41, 0x9f, 0xc4, 0x67, 0x25, 0x7e, 0x86, 0x41, 0x87, 0xd0, 0x8d, 0xe8, 0xf0,
	0x92, 0xb0, 0x37, 0x63, 0x91, 0xf0, 0x8e, 0xa4, 0x58, 0x68, 0x69, 0xaf, 0x66, 0x26, 0x25, 0x49,
	0x15, 0x27, 0x94, 0xa0, 0x16, 0x82, 0xbf, 0x2c, 0x80, 0x59, 0x9e, 0xd0, 0x73, 0x68, 0xa9, 0xfe,
	0xa5, 0xbb, 0x6f, 0x6f, 0x79, 0x5d, 0xcf, 0x10, 0x42, 0x8a, 0x0a, 0x81, 0xfa, 0x52, 0x8a, 0x2b,
	0xe4, 0x7b, 0x44, 0x6b, 0x98, 0xc6, 0x88, 0xa2, 0x27, 0x60, 0x67, 0x71, 0xa6, 0xb5, 0xbb, 0x70,
	0x02, 0xa7, 0x71, 0x56, 0x43, 0x08, 0xdb, 0xc1, 0x66, 0xd5, 0xd9, 0x80, 0xc1, 0x8d, 0x79, 0x77,
	0xd0, 0x1d, 0x70, 0xcb, 0xd6, 0xa9, 0xa5, 0x33, 0x9b, 0x28, 0x0b, 0xb3, 0x31, 0x2b, 0x4c, 0xa1,
	0x48, 0x1d, 0xb2, 0x2a, 0x57, 0x13, 0xce, 0x36, 0x34, 0xe5, 0xad, 0xe5, 0x41, 0xcf, 0xda, 0xe9,
	0x60, 0x35, 0x08, 0x76, 0x60, 0xb3, 0x1a, 0xca, 0x6a, 0xf5, 0x07, 0x0f, 0xe0, 0x5a, 0x2d, 0x86,
	0x55, 0x45, 0x16, 0x5c, 0xc2, 0xb5, 0x9a, 0xdc, 0x04, 0xa7, 0x91, 0xa7, 0xe6, 0x34, 0xea, 0x43,
	0xe0, 0x84, 0x6c, 0xa4, 0x04, 0xef, 0x62, 0xf9, 0x2d, 0xac, 0x7f, 0xa5, 0xec, 0x32, 0x8a, 0x99,
	0x0e, 0xc0, 0x0c, 0x85, 0x35, 0x49, 0x27, 0xea, 0xee, 0x71, 0xb1, 0xfc, 0x0e, 0x32, 0xd8, 0xaa,
	0xeb, 0xf3, 0x3d, 0xf5, 0x7b, 0x13, 0x5a, 0xb4, 0xe0, 0x59, 0x61, 0x2a, 0x58, 0x8f, 0x04, 0x22,
	0x4e, 0x73, 0x1e, 0x26, 0x89, 0xdc, 0xb1, 0x83, 0xcd, 0x70, 0xe9, 0x8e, 0x07, 0x70, 0x7d, 0x4e,
	0xd2, 0x55, 0x97, 0xad, 0xba, 0xcb, 0xdb, 0xd0, 0xcc, 0x09, 0x2f, 0x32, 0x73, 0x25, 0xc9, 0x41,
	0xf0, 0xb7, 0x05, 0xff, 0x5b, 0xd0, 0x34, 0xba, 0x27, 0x2e, 0xd8, 0x8c, 0xe6, 0x31, 0xa7, 0xcc,
	0x5c, 0x22, 0x95, 0x19, 0xc1, 0x15, 0xcb, 0x2a, 0xd1, 0x5c, 0x72, 0x80, 0x5e, 0x42, 0x47, 0x67,
	0xd3, 0xdc, 0xeb, 0x0f, 0xde, 0x53, 0x3e, 0xf2, 0x61, 0xa2, 0x4f, 0x07, 0x97, 0x40, 0xa9, 0xa3,
	0x22, 0xbf, 0xf0, 0x1c, 0x19, 0xbe, 0xfc, 0x46, 0x01, 0x6c, 0xe6, 0x84, 0x9f, 0x84, 0x9c, 0xe4,
	0xfc, 0x6d, 0x38, 0x92, 0x9d, 0xa5, 0x83, 0x6b, 0x73, 0xc1, 0x1f, 0x00, 0xb7, 0x56, 0xb0, 0xa3,
	0x01, 0x38, 0xe7, 0x8c, 0x8e, 0x75, 0xe1, 0x3d, 0x5a, 0xd3, 0xa9, 0xfe, 0x6b, 0x46, 0xc7, 0xc7,
	0x1b, 0x58, 0x62, 0xd1, 0x21, 0x34, 0x93, 0xf0, 0x8c, 0x24, 0xba, 0x0a, 0x1f, 0xaf, 0x4b, 0x72,
	0x22, 0x40, 0xc7, 0x1b, 0x58, 0xa1, 0xd1, 0x0b, 0xb0, 0xc3, 0x28, 0xd2, 0x95, 0xf9, 0xc9, 0xba,
	0x24, 0x07, 0x51, 0x24, 0xea, 0x34, 0x8c, 0x64, 0x2c, 0x43, 0x9a, 0x4d, 0x65, 0x7e, 0xae, 0x10,
	0xcb, 0x4b, 0x9a, 0x89, 0x52, 0x97, 0x58, 0xe1, 0x04, 0x2b, 0x52, 0xdd, 0xa0, 0xd7, 0x76, 0x02,
	0x17, 0xa9, 0x70, 0x82, 0x15, 0x29, 0x7a, 0x0b, 0x40, 0xc4, 0x33, 0x23, 0xa3, 0x71, 0xca, 0x75,
	0xb3, 0xde, 0x5b, 0x97, 0xe7, 0xb0, 0x44, 0x1e, 0x6f, 0xe0, 0x0a, 0x0f, 0x3a, 0x86, 0x16, 0xf9,
	0x2d, 0xa3, 0x39, 0xd1, 0xfd, 0xbb, 0xbf, 0x36, 0xa3, 0x44, 0x89, 0x7e, 0xa9, 0xf0, 0x82, 0x69,
	0x42, 0x93, 0x62, 0x6c, 0xda, 0xf8, 0xda, 0x4c, 0x3f, 0x49, 0x94, 0x60, 0x52, 0x78, 0x91, 0xee,
	0x22, 0x27, 0xcc, 0x73, 0xaf, 0x96, 0xee, 0x1f, 0x73, 0xf9, 0x34, 0x90, 0x58, 0xf4, 0xed, 0xac,
	0x26, 0x41, 0xd2, 0xec, 0xae, 0x4b, 0xf3, 0x4e, 0xc1, 0xc4, 0x2d, 0x69, 0xca, 0xf8, 0x05, 0xd8,
	0x24, 0x9d, 0x78, 0xdd, 0xab, 0x9d, 0xdd, 0x61, 0x3a, 0x11, 0x67, 0x47, 0xd2, 0x89, 0xef, 0x83,
	0x23, 0x84, 0xbd, 0xec, 0xa9, 0xe4, 0xef, 0x42, 0x53, 0xea, 0x75, 0xdd, 0x17, 0xad, 0xff, 0x06,
	0xec, 0x83, 0x28, 0x42, 0x7d, 0x70, 0xce, 0xe3, 0xc4, 0xfc, 0x57, 0xf8, 0x8b, 0x8f, 0xb8, 0x84,
	0xfc, 0x40, 0x0b, 0x36, 0x24, 0x58, 0xda, 0x2d, 0xbb, 0x2c, 0xfc, 0x6f, 0xc0, 0x11, 0x22, 0xfd,
	0x20, 0x5c, 0xf7, 0xc1, 0xc6, 0x45, 0xba, 0xba, 0xdb, 0xfb, 0x3d, 0x80, 0x99, 0x0c, 0xcb, 0xde,
	0x6f, 0xcd, 0x7a, 0xbf, 0x7f, 0x0f, 0x5a, 0x4a, 0x56, 0x22, 0xf2, 0x8c, 0x32, 0xfd, 0xd0, 0x6d,
	0x62, 0x35, 0x10, 0xeb, 0x4a, 0x2c, 0x72, 0x3d, 0xe4, 0x17, 0x06, 0xae, 0x06, 0x22, 0xcd, 0x42,
	0x04, 0x4b, 0xd3, 0x7c, 0x17, 0xda, 0xef, 0x66, 0x17, 0x89, 0xf4, 0xde, 0xaa, 0x78, 0xff, 0x18,
	0xec, 0xc3, 0x74, 0xb2, 0xee, 0x19, 0x0c, 0x5c, 0x68, 0xeb, 0x63, 0x0e, 0x7e, 0x07, 0x98, 0xe5,
	0x07, 0x3d, 0xac, 0x65, 0x72, 0x7b, 0x59, 0x26, 0x65, 0x7b, 0x13, 0x59, 0x7c, 0x0a, 0x9d, 0x90,
	0xf1, 0xf8, 0x3c, 0x1c, 0x72, 0xdd, 0xe1, 0x16, 0x9e, 0xbc, 0x07, 0x7a, 0x5d, 0x3c, 0xbb, 0x8c,
	0xad, 0x78, 0xee, 0xa8, 0xdd, 0x82, 0xaf, 0xc1, 0x91, 0xbf, 0x99, 0xef, 0x7f, 0x26, 0xf8, 0xd0,
	0x11, 0xfb, 0xc9, 0x94, 0xa8, 0x28, 0xca, 0x71, 0x90, 0x41, 0xc7, 0xec, 0xf1, 0x01, 0x1f, 0x1b,
	0xd5, 0x1d, 0x9d, 0xfa, 0x8e, 0x83, 0x5d, 0xb8, 0x3d, 0xa4, 0xe3, 0xfe, 0x28, 0xe6, 0x17, 0xc5,
	0xd9, 0x5c, 0xbc, 0x03, 0x90, 0x15, 0x74, 0x2a, 0x7e, 0xac, 0x4f, 0xad, 0x5f, 0x1c, 0x31, 0x77,
	0xd6, 0x92, 0xff, 0xd9, 0x9f, 0xfd, 0x17, 0x00, 0x00, 0xff, 0xff, 0x43, 0xfe, 0x78, 0x44, 0x7b,
	0x0f, 0x00, 0x00,
}
